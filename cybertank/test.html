<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tank Physics Demo - Simulation Air Tumble</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        
        canvas { 
            display: block; 
            touch-action: none; 
        }

        #fullscreen-prompt { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: white; background-color: rgba(0, 0, 0, 0.5); padding: 8px 15px; border-radius: 20px; font-family: sans-serif; font-size: 14px; pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 10; }
        
        .ui-button {
            position: absolute;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.4);
            cursor: pointer;
            padding: 10px;
            z-index: 100;
            opacity: 0.8;
            transition: opacity 0.2s, background-color 0.2s;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .ui-button:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.5);
        }
        .ui-button svg {
            display: block;
            width: 32px;
            height: 32px;
        }

        #music-toggle-btn { top: 15px; right: 15px; border-radius: 8px; }
        #reset-btn { top: 15px; right: 85px; border-radius: 8px; }
        #jump-btn { position: absolute; bottom: 30px; right: 50px; width: 80px; height: 80px; }
        #joystick-container { position: absolute; bottom: 30px; left: 50px; width: 120px; height: 120px; z-index: 10; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.149.0",
                "three/addons/": "https://esm.sh/three@0.149.0/examples/jsm/",
                "@dimforge/rapier3d-compat": "https://esm.sh/@dimforge/rapier3d-compat@0.13.1"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
</head>

<body>
    <!-- UI Elements -->
    <div id="joystick-container"></div>
    <button id="jump-btn" class="ui-button" aria-label="Jump">
        <svg xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 0 24 24" width="48px" fill="#76FF33"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z"/></svg>
    </button>
    <button id="reset-btn" class="ui-button" aria-label="Reset Tank">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#76FF33"><path d="M12 4c-4.41 0-8 3.59-8 8s3.59 8 8 8 8-3.59 8-8-3.59-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm-1-8v4h2v-4h3l-4-4-4 4h3z" fill-rule="evenodd"/></svg>
    </button>
    <button id="music-toggle-btn" class="ui-button" aria-label="Toggle Music">
        <span id="music-icon-on" style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#76FF33"><path d="M12 3v9.28c-.47-.17-.97-.28-1.5-.28C8.01 12 6 14.01 6 16.5S8.01 21 10.5 21c2.31 0 4.2-1.75 4.45-4H15V6h4V3h-7z"/></svg></span>
        <span id="music-icon-off"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#76FF33"><path d="M4.27 3L3 4.27l9 9v.28c-.47-.17-.97-.28-1.5-.28-2.49 0-4.5 2.01-4.5 4.5S8.01 21 10.5 21c2.31 0 4.2-1.75 4.45-4H15v-1.73l5.73 5.73L22 19.73 4.27 3zM15 6h4V3h-7v4.18l2 2z"/></svg></span>
    </button>
    <div id="fullscreen-prompt">Tap to enter fullscreen & lock landscape</div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
        import RAPIER from '@dimforge/rapier3d-compat';

        let scene, camera, renderer, world;
        let tankModel, tankBody;
        
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        let audioContext, audioBuffer, sourceNode, isPlaying = false;

        const joystickVector = new THREE.Vector2();
        const keyboard = { forward: 0, turn: 0 };
        const cameraAngle = { horizontal: Math.PI, vertical: 0.4 };
        const cameraOffset = new THREE.Vector3(0, 4, 12);
        
        const maxSpeed = 25.0;
        const turnSpeed = 0.1;
        const jumpForce = 2500;
        const groundRaycastDist = 1.5;
        const initialTankPosition = { x: 0, y: 2, z: 0 };

        init();

        async function init() {
            await RAPIER.init();
            world = new RAPIER.World({ x: 0.0, y: -9.81, z: 0.0 });
            scene = new THREE.Scene();
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffeeb1, 1);
            directionalLight.position.set(-20, 30, 20);
            scene.add(directionalLight);
            
            loadAssetsAndPhysics();
            setupControls();
            setupMusicControls();
            setupFullscreen();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        async function loadAssetsAndPhysics() {
            const exrLoader = new EXRLoader();
            const gltfLoader = new GLTFLoader();
            const loadGltfAsync = (url) => new Promise((resolve, reject) => gltfLoader.load(url, resolve, undefined, reject));
            const loadExrAsync = (url) => new Promise((resolve, reject) => exrLoader.load(url, resolve, undefined, reject));
            try {
                const texture = await loadExrAsync('assets/Minigame_Synth_Environment_4096x2048.exr');
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.environment = texture;
                const sceneGltf = await loadGltfAsync('assets/Minigame_Synth_Scene.glb');
                const sceneModel = sceneGltf.scene;
                scene.add(sceneModel);
                const sceneBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed());
                sceneModel.traverse(child => {
                    if (child.isMesh) {
                        child.receiveShadow = true;
                        child.updateWorldMatrix(true, true);
                        const geometry = child.geometry;
                        if (!geometry.attributes.position || !geometry.index) return;
                        const vertices = geometry.attributes.position.array.slice();
                        const indices = geometry.index.array.slice();
                        for (let i = 0; i < vertices.length; i += 3) {
                            const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
                            vertex.applyMatrix4(child.matrixWorld);
                            vertices[i] = vertex.x;
                            vertices[i + 1] = vertex.y;
                            vertices[i + 2] = vertex.z;
                        }
                        const trimeshDesc = RAPIER.ColliderDesc.trimesh(new Float32Array(vertices), indices);
                        world.createCollider(trimeshDesc, sceneBody);
                    }
                });
                const tankGltf = await loadGltfAsync('assets/Minigame_Synth_Tank.glb');
                tankModel = tankGltf.scene;
                tankModel.position.set(initialTankPosition.x, initialTankPosition.y, initialTankPosition.z);
                scene.add(tankModel);
                // Increased angular damping slightly to prevent endless spinning, but still allows tumbling.
                const bodyDesc = RAPIER.RigidBodyDesc.dynamic()
                    .setTranslation(tankModel.position.x, tankModel.position.y, tankModel.position.z)
                    .setLinearDamping(0.5)
                    .setAngularDamping(0.5) // Original was 0.8, a lower value allows for more tumbling
                    .setCanSleep(false);
                tankBody = world.createRigidBody(bodyDesc);
                const allVertices = [];
                tankModel.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        const positions = child.geometry.attributes.position.array;
                        for (let i = 0; i < positions.length; i += 3) { allVertices.push(positions[i], positions[i+1], positions[i+2]); }
                    }
                });
                const colliderDesc = RAPIER.ColliderDesc.convexHull(new Float32Array(allVertices));
                world.createCollider(colliderDesc, tankBody);
            } catch (error) {
                console.error("An error occurred during asset loading:", error);
            }
        }

        function setupControls() {
            if (isTouchDevice) {
                const joystickManager = nipplejs.create({ zone: document.getElementById('joystick-container'), mode: 'static', position: { left: '80px', bottom: '80px' }, color: 'rgba(255,255,255,0.5)' });
                joystickManager.on('move', (evt, data) => { joystickVector.set(data.vector.x, data.vector.y); }).on('end', () => { joystickVector.set(0, 0); });
            }
            document.addEventListener('keydown', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w': case 'arrowup':    keyboard.forward = 1; break;
                    case 's': case 'arrowdown':  keyboard.forward = -1; break;
                    case 'a': case 'arrowleft':  keyboard.turn = -1; break;
                    case 'd': case 'arrowright': keyboard.turn = 1; break;
                    case ' ':                    handleJump(); break;
                }
            });
            document.addEventListener('keyup', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w': case 'arrowup': case 's': case 'arrowdown':  keyboard.forward = 0; break;
                    case 'a': case 'arrowleft': case 'd': case 'arrowright': keyboard.turn = 0; break;
                }
            });
            
            const cameraPointers = {};
            const rotationSpeed = 0.005;
            const tapThreshold = 10;
            const pointerDownPos = new THREE.Vector2();

            const onPointerDown = (e) => {
                if (e.target.closest('.ui-button') || e.target.closest('#joystick-container')) return;
                cameraPointers[e.pointerId] = { x: e.clientX, y: e.clientY };
                pointerDownPos.set(e.clientX, e.clientY);
            };
            const onPointerMove = (e) => {
                const pointer = cameraPointers[e.pointerId];
                if (pointer) {
                    const deltaX = e.clientX - pointer.x;
                    const deltaY = e.clientY - pointer.y;
                    cameraAngle.horizontal -= deltaX * rotationSpeed;
                    cameraAngle.vertical -= deltaY * rotationSpeed;
                    cameraAngle.vertical = Math.max(-Math.PI / 4, Math.min(Math.PI / 2.5, cameraAngle.vertical));
                    pointer.x = e.clientX;
                    pointer.y = e.clientY;
                }
            };
            const onPointerUpOrCancel = (e) => {
                if (cameraPointers[e.pointerId]) {
                    const dragDistance = pointerDownPos.distanceTo(new THREE.Vector2(e.clientX, e.clientY));
                    if (dragDistance < tapThreshold) handleFullscreenRequest();
                }
                delete cameraPointers[e.pointerId];
            };
            
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            renderer.domElement.addEventListener('pointerup', onPointerUpOrCancel);
            renderer.domElement.addEventListener('pointercancel', onPointerUpOrCancel);
            renderer.domElement.addEventListener('pointerleave', onPointerUpOrCancel);

            const jumpButton = document.getElementById('jump-btn');
            const resetButton = document.getElementById('reset-btn');
            jumpButton.addEventListener('touchstart', (e) => { e.preventDefault(); handleJump(); }, { passive: false });
            jumpButton.addEventListener('click', handleJump);
            const resetTank = () => {
                if (!tankBody) return;
                tankBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
                tankBody.setAngvel({ x: 0, y: 0, z: 0 }, true);
                tankBody.setTranslation(initialTankPosition, true);
                tankBody.setRotation({ x: 0, y: 0, z: 0, w: 1 }, true);
            };
            resetButton.addEventListener('touchstart', (e) => { e.preventDefault(); resetTank(); }, { passive: false });
            resetButton.addEventListener('click', resetTank);
        }
        
        function handleJump() {
            if (!tankBody) return;
            const rayOrigin = tankBody.translation();
            const rayDir = { x: 0, y: -1, z: 0 };
            const ray = new RAPIER.Ray(rayOrigin, rayDir);
            const hit = world.castRay(ray, groundRaycastDist, true, null, null, tankBody.collider(0));
            if (hit) {
                tankBody.applyImpulse({ x: 0, y: jumpForce, z: 0 }, true);
            }
        }

        const cameraForward = new THREE.Vector3();
        const cameraRight = new THREE.Vector3();
        const moveDirection = new THREE.Vector3();
        const targetVelocity = new THREE.Vector3();
        const targetQuaternion = new THREE.Quaternion();
        const _matrix = new THREE.Matrix4();
        const upVector = new THREE.Vector3(0, 1, 0);

        const groundNormal = new THREE.Vector3(0, 1, 0);
        const currentUpVector = new THREE.Vector3(0, 1, 0);

        function animate() {
            requestAnimationFrame(animate);
            world.step();

            if (tankBody && tankModel) {
                const moveInput = new THREE.Vector2( isTouchDevice ? joystickVector.x : keyboard.turn, isTouchDevice ? joystickVector.y : keyboard.forward );
                camera.getWorldDirection(cameraForward);
                cameraForward.y = 0;
                cameraForward.normalize();
                cameraRight.crossVectors(cameraForward, upVector);
                moveDirection.set(0, 0, 0);
                moveDirection.addScaledVector(cameraForward, moveInput.y);
                moveDirection.addScaledVector(cameraRight, moveInput.x);

                const currentVel = tankBody.linvel();
                if (moveDirection.lengthSq() > 0.01) {
                    moveDirection.normalize();
                    targetVelocity.copy(moveDirection).multiplyScalar(maxSpeed);
                    tankBody.setLinvel({ x: targetVelocity.x, y: currentVel.y, z: targetVelocity.z }, true);
                } else {
                    tankBody.setLinvel({ x: 0, y: currentVel.y, z: 0 }, true);
                }
                
                // --- TANK ORIENTATION LOGIC ---
                const rayOrigin = tankBody.translation();
                rayOrigin.y += 0.5;
                const rayDir = { x: 0, y: -1, z: 0 };
                const ray = new RAPIER.Ray(rayOrigin, rayDir);
                const hit = world.castRayAndGetNormal(ray, 2.0, true, null, null, tankBody.collider(0));

                let isOnGround = false; // A flag to know if we are on ground
                if (hit) {
                    isOnGround = true;
                    groundNormal.set(hit.normal.x, hit.normal.y, hit.normal.z);
                } else {
                    // MODIFIED: In-air behavior
                    // Do nothing here. This lets the physics engine control the tumble.
                    // We let 'groundNormal' keep its last value from when it was on the ground.
                }
                
                // We only force the tank's orientation when it's on the ground.
                if (isOnGround) {
                    currentUpVector.lerp(groundNormal, 0.1);
                    const lookDirection = moveDirection.lengthSq() > 0.01 ? moveDirection : cameraForward;
                    _matrix.lookAt(tankModel.position, tankModel.position.clone().sub(lookDirection), currentUpVector);
                    targetQuaternion.setFromRotationMatrix(_matrix);
                    
                    // Slerp to the new target rotation.
                    // Since this only runs on the ground, it won't interfere with air tumbling.
                    const currentRotation = new THREE.Quaternion().copy(tankBody.rotation());
                    currentRotation.slerp(targetQuaternion, turnSpeed);
                    tankBody.setRotation(currentRotation, true);
                }
                
                // Always sync model position and rotation with the physics body.
                // This is crucial for displaying the in-air tumble correctly.
                const position = tankBody.translation();
                tankModel.position.set(position.x, position.y, position.z);
                const rotation = tankBody.rotation();
                tankModel.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);


                // --- CAMERA LOGIC (Unchanged) ---
                const rotatedOffset = cameraOffset.clone().applyAxisAngle(upVector, cameraAngle.horizontal);
                const horizontalAxis = new THREE.Vector3().crossVectors(upVector, rotatedOffset).normalize();
                rotatedOffset.applyAxisAngle(horizontalAxis, cameraAngle.vertical);
                const cameraTargetPosition = tankModel.position.clone().add(rotatedOffset);
                camera.position.lerp(cameraTargetPosition, 0.1);
                camera.lookAt(tankModel.position.clone().add(new THREE.Vector3(0, 1.5, 0)));
            }
            renderer.render(scene, camera);
        };
        
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
        
        function handleFullscreenRequest() { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().then(() => { if (isTouchDevice && screen.orientation && typeof screen.orientation.lock === 'function') { screen.orientation.lock('landscape').catch(() => {}); } }).catch(() => {}); } }
        
        function setupFullscreen() { 
            const prompt = document.getElementById('fullscreen-prompt'); 
            if (isTouchDevice) { 
                setTimeout(() => { prompt.style.opacity = '1'; }, 2000); 
                setTimeout(() => { prompt.style.opacity = '0'; }, 7000); 
            } else { 
                renderer.domElement.addEventListener('click', (e) => { 
                    if(e.target.closest('.ui-button')) return; 
                    handleFullscreenRequest()
                }); 
            } 
            document.addEventListener('fullscreenchange', () => { if (!document.fullscreenElement) { if (screen.orientation && typeof screen.orientation.unlock === 'function') { screen.orientation.unlock(); } } }); 
        };

        async function setupMusicControls() { 
            const musicButton = document.getElementById('music-toggle-btn'); 
            const iconOn = document.getElementById('music-icon-on'); 
            const iconOff = document.getElementById('music-icon-off'); 
            try { 
                const response = await fetch('assets/bounce tanki loop cut (no intro).opus'); 
                const arrayBuffer = await response.arrayBuffer(); 
                audioContext = THREE.AudioContext.getContext(); 
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer); 
            } catch (error) { 
                console.error('Failed to load or decode audio file:', error); 
                musicButton.disabled = true; 
                return; 
            } 
            function playMusic() { 
                if (isPlaying || !audioBuffer) return; 
                sourceNode = audioContext.createBufferSource(); 
                sourceNode.buffer = audioBuffer; 
                sourceNode.loop = true; 
                sourceNode.connect(audioContext.destination); 
                sourceNode.start(); 
                isPlaying = true; 
                iconOn.style.display = 'inline'; 
                iconOff.style.display = 'none'; 
            } 
            function stopMusic() { 
                if (!isPlaying || !sourceNode) return; 
                sourceNode.stop(); 
                sourceNode.disconnect(); 
                sourceNode = null; 
                isPlaying = false; 
                iconOn.style.display = 'none'; 
                iconOff.style.display = 'inline'; 
            } 
            musicButton.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                if (audioContext.state === 'suspended') { audioContext.resume(); } 
                if (isPlaying) { 
                    stopMusic(); 
                } else { 
                    playMusic(); 
                } 
            }); 
        }
    </script>
</body>

</html>
