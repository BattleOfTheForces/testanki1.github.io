<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tank Physics Demo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
        }

        #fullscreen-prompt {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 20px;
            font-family: sans-serif;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 10;
        }

        #music-toggle-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            z-index: 100;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        #music-toggle-btn:hover {
            opacity: 1;
        }

        #music-toggle-btn svg {
            display: block;
        }
        
        /* Joystick container */
        #joystick-zone {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            background: rgba(128, 128, 128, 0.2);
            border-radius: 50%;
            z-index: 50;
        }
        
        /* Hide joystick on non-touch devices */
        .no-touch #joystick-zone {
            display: none;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.149.0/examples/jsm/",
            "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.mjs",
            "nipplejs": "https://cdn.jsdelivr.net/npm/nipplejs@0.10.1/dist/nipplejs.mjs"
        }
    }
    </script>

</head>

<body>
    <div id="fullscreen-prompt">Tap to enter fullscreen & lock landscape</div>
    <button id="music-toggle-btn" aria-label="Toggle Music">
        <span id="music-icon-on" style="display: none;">
            <svg xmlns="http://www.w3.org/2000/svg" height="32px" viewBox="0 0 24 24" width="32px" fill="#76FF33">
                <path d="M0 0h24v24H0V0z" fill="none" />
                <path d="M12 3v9.28c-.47-.17-.97-.28-1.5-.28C8.01 12 6 14.01 6 16.5S8.01 21 10.5 21c2.31 0 4.2-1.75 4.45-4H15V6h4V3h-7zM10.5 19c-1.38 0-2.5-1.12-2.5-2.5S9.12 14 10.5 14s2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" />
            </svg>
        </span>
        <span id="music-icon-off">
            <svg xmlns="http://www.w3.org/2000/svg" height="32px" viewBox="0 0 24 24" width="32px" fill="#76FF33">
                <path d="M0 0h24v24H0V0z" fill="none" />
                <path d="M4.27 3L3 4.27l9 9v.28c-.47-.17-.97-.28-1.5-.28C8.01 13.5 6 15.51 6 18s2.01 4.5 4.5 4.5S15 20.49 15 18v-1.73L19.73 21 21 19.73 4.27 3zM10.5 19.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zM12 10.15v-7.1h4V6h-4v2.87l2.13 2.13z" />
            </svg>
        </span>
    </button>
    
    <div id="joystick-zone"></div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
        import * as CANNON from 'cannon-es';
        import nipplejs from 'nipplejs';

        let scene, camera, renderer, world, clock;
        let tankModel, tankBody, cameraPivot;
        
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (!isTouchDevice) {
            document.body.classList.add('no-touch');
        }

        // Tank control state
        const tankControls = { forward: 0, turn: 0 };
        const TANK_SPEED = 6;
        const TANK_TURN_SPEED = 1.5;

        // Music
        let audioContext;
        let audioBuffer;
        let sourceNode;
        let isPlaying = false;

        init();
        animate();

        function init() {
            // === THREE.js Setup ===
            scene = new THREE.Scene();
            clock = new THREE.Clock();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Camera Pivot for orbit controls
            cameraPivot = new THREE.Object3D();
            cameraPivot.add(camera);
            scene.add(cameraPivot);
            camera.position.set(0, 5, 10); // Offset from pivot
            camera.lookAt(cameraPivot.position);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffeeb1, 1);
            directionalLight.position.set(-20, 30, 20);
            scene.add(directionalLight);

            // === CANNON.js Physics Setup ===
            world = new CANNON.World({
                gravity: new CANNON.Vec3(0, -9.82, 0)
            });
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.allowSleep = true; // Performance improvement

            loadAssetsAndCreatePhysics();
            setupControls();
            setupMusicControls();
            setupFullscreen();
            window.addEventListener('resize', onWindowResize);
        }

        // Helper to create Cannon.js Trimesh from Three.js BufferGeometry
        function createTrimesh(geometry) {
            const vertices = geometry.attributes.position.array;
            const indices = geometry.index ? geometry.index.array : Array.from(Array(vertices.length / 3).keys());
            return new CANNON.Trimesh(vertices, indices);
        }

        function loadAssetsAndCreatePhysics() {
            const exrLoader = new EXRLoader();
            const gltfLoader = new GLTFLoader();

            exrLoader.load('assets/Minigame_Synth_Environment_4096x2048.exr', (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.environment = texture;

                // Load Scene and create static collision meshes
                gltfLoader.load('assets/Minigame_Synth_Scene.glb', (gltf) => {
                    const sceneModel = gltf.scene;
                    scene.add(sceneModel);

                    // Create static physics body from the scene's geometry
                    sceneModel.traverse(child => {
                        if (child.isMesh && child.geometry) {
                            const trimeshShape = createTrimesh(child.geometry);
                            const trimeshBody = new CANNON.Body({ mass: 0 }); // mass 0 makes it static
                            
                            // Apply world transform from Three.js mesh to Cannon.js body
                            const worldPosition = new THREE.Vector3();
                            const worldQuaternion = new THREE.Quaternion();
                            child.getWorldPosition(worldPosition);
                            child.getWorldQuaternion(worldQuaternion);
                            trimeshBody.position.copy(worldPosition);
                            trimeshBody.quaternion.copy(worldQuaternion);
                            
                            trimeshBody.addShape(trimeshShape);
                            world.addBody(trimeshBody);
                        }
                    });
                });

                // Load Tank and create dynamic collision body
                gltfLoader.load('assets/Minigame_Synth_Tank.glb', (gltf) => {
                    tankModel = gltf.scene;
                    scene.add(tankModel);

                    // Create a simplified dynamic physics body for the tank (a box)
                    const boundingBox = new THREE.Box3().setFromObject(tankModel);
                    const size = new THREE.Vector3();
                    boundingBox.getSize(size);
                    const tankShape = new CANNON.Box(new CANNON.Vec3(size.x / 2 * 0.9, size.y / 2 * 0.8, size.z / 2 * 0.95));
                    
                    tankBody = new CANNON.Body({
                        mass: 700,
                        shape: tankShape,
                        position: new CANNON.Vec3(0, 5, 0), // Start above the ground
                        material: new CANNON.Material({ friction: 0.1, restitution: 0.1 })
                    });
                    tankBody.angularDamping = 0.8; // Prevents infinite spinning
                    world.addBody(tankBody);
                });
            });
        }
        
        function setupControls() {
            if (isTouchDevice) {
                setupJoystick();
                setupCameraTouchControls();
            } else {
                setupCameraMouseControls();
                setupKeyboardControls(); // Add keyboard controls for desktop
            }
        }

        function setupJoystick() {
            const joystickZone = document.getElementById('joystick-zone');
            const options = {
                zone: joystickZone,
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: 'white',
                size: 120
            };
            const manager = nipplejs.create(options);
            
            manager.on('move', (evt, data) => {
                const angle = data.angle.radian;
                const force = data.force;
                // Convert joystick angle to tank forward/turn controls
                tankControls.forward = force * Math.sin(angle);
                tankControls.turn = -force * Math.cos(angle);
            });

            manager.on('end', () => {
                tankControls.forward = 0;
                tankControls.turn = 0;
            });
        }

        function setupKeyboardControls() {
            window.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case 'w': case 'ArrowUp':    tankControls.forward = 1; break;
                    case 's': case 'ArrowDown':  tankControls.forward = -1; break;
                    case 'a': case 'ArrowLeft':  tankControls.turn = 1; break;
                    case 'd': case 'ArrowRight': tankControls.turn = -1; break;
                }
            });
            window.addEventListener('keyup', (e) => {
                switch(e.key) {
                    case 'w': case 'ArrowUp':
                    case 's': case 'ArrowDown':  tankControls.forward = 0; break;
                    case 'a': case 'ArrowLeft':
                    case 'd': case 'ArrowRight': tankControls.turn = 0; break;
                }
            });
        }
        
        function updateTankMovement() {
            if (!tankBody) return;

            // Calculate forward vector based on tank's rotation
            const forwardVector = new CANNON.Vec3(0, 0, 1);
            const rotatedForward = tankBody.quaternion.vmult(forwardVector);
            
            // Apply velocity for forward/backward movement
            const targetVelocity = rotatedForward.scale(tankControls.forward * TANK_SPEED);
            // Preserve vertical velocity (gravity)
            targetVelocity.y = tankBody.velocity.y;
            tankBody.velocity.lerp(targetVelocity, 0.2, tankBody.velocity);

            // Apply angular velocity for turning
            const targetAngularVelocity = new CANNON.Vec3(0, tankControls.turn * TANK_TURN_SPEED, 0);
            tankBody.angularVelocity.lerp(targetAngularVelocity, 0.5, tankBody.angularVelocity);
        }

        function setupCameraTouchControls() {
            const musicButton = document.getElementById('music-toggle-btn');
            const joystickZone = document.getElementById('joystick-zone');
            const activeTouches = {};
            let previousPinchDistance = null;
            const rotationSpeed = 0.005;
            const pinchSpeed = 0.02;

            const onTouchStart = (e) => {
                // Ignore touches starting on UI elements
                if (musicButton.contains(e.target) || joystickZone.contains(e.target)) return;
                
                for (const touch of e.changedTouches) {
                    activeTouches[touch.identifier] = { prevX: touch.clientX, prevY: touch.clientY };
                }
                if (Object.keys(activeTouches).length === 2) {
                     const t0 = e.touches[0];
                     const t1 = e.touches[1];
                     previousPinchDistance = Math.hypot(t1.clientX - t0.clientX, t1.clientY - t0.clientY);
                }
            };

            const onTouchMove = (e) => {
                if (musicButton.contains(e.target) || joystickZone.contains(e.target)) return;
                e.preventDefault();

                const touchCount = Object.keys(activeTouches).length;
                if (touchCount === 1) { // Single finger drag for rotation
                    const touchId = Object.keys(activeTouches)[0];
                    const touch = Array.from(e.touches).find(t => t.identifier == touchId);
                    if (touch) {
                        const state = activeTouches[touchId];
                        const deltaX = touch.clientX - state.prevX;
                        const deltaY = touch.clientY - state.prevY;
                        cameraPivot.rotation.y -= deltaX * rotationSpeed;
                        cameraPivot.rotation.x -= deltaY * rotationSpeed;
                        cameraPivot.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPivot.rotation.x));
                        state.prevX = touch.clientX;
                        state.prevY = touch.clientY;
                    }
                } else if (touchCount === 2) { // Two finger pinch for zoom
                    const t0 = e.touches[0];
                    const t1 = e.touches[1];
                    const currentPinchDistance = Math.hypot(t1.clientX - t0.clientX, t1.clientY - t0.clientY);
                    if (previousPinchDistance) {
                        const deltaPinch = currentPinchDistance - previousPinchDistance;
                        camera.position.z -= deltaPinch * pinchSpeed;
                        camera.position.z = Math.max(2, Math.min(30, camera.position.z)); // Clamp zoom
                    }
                    previousPinchDistance = currentPinchDistance;
                }
            };

            const onTouchEnd = (e) => {
                for (const touch of e.changedTouches) {
                    delete activeTouches[touch.identifier];
                }
                if (Object.keys(activeTouches).length < 2) {
                    previousPinchDistance = null;
                }
            };

            const targetElement = renderer.domElement;
            targetElement.addEventListener('touchstart', onTouchStart, { passive: true });
            targetElement.addEventListener('touchmove', onTouchMove, { passive: false });
            targetElement.addEventListener('touchend', onTouchEnd, { passive: true });
        }
        
        function setupCameraMouseControls() {
            let isDragging = false;
            let prevMouse = {x: 0, y: 0};
            const rotationSpeed = 0.005;

            renderer.domElement.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // Left mouse button
                    isDragging = true;
                    prevMouse.x = e.clientX;
                    prevMouse.y = e.clientY;
                }
            });

             renderer.domElement.addEventListener('mousemove', (e) => {
                if(isDragging) {
                    const deltaX = e.clientX - prevMouse.x;
                    const deltaY = e.clientY - prevMouse.y;
                    cameraPivot.rotation.y -= deltaX * rotationSpeed;
                    cameraPivot.rotation.x -= deltaY * rotationSpeed;
                    cameraPivot.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPivot.rotation.x));
                    prevMouse.x = e.clientX;
                    prevMouse.y = e.clientY;
                }
            });

            renderer.domElement.addEventListener('mouseup', () => isDragging = false);
            renderer.domElement.addEventListener('mouseleave', () => isDragging = false);

            renderer.domElement.addEventListener('wheel', (e) => {
                camera.position.z += e.deltaY * 0.01;
                camera.position.z = Math.max(2, Math.min(30, camera.position.z));
            });
        }
        
        async function setupMusicControls() {
            // This function remains the same as provided
            const musicButton = document.getElementById('music-toggle-btn');
            const iconOn = document.getElementById('music-icon-on');
            const iconOff = document.getElementById('music-icon-off');
            try {
                const response = await fetch('assets/bounce tanki loop cut (no intro).opus');
                const arrayBuffer = await response.arrayBuffer();
                audioContext = THREE.AudioContext.getContext();
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            } catch (error) {
                console.error('Failed to load or decode audio file:', error);
                musicButton.disabled = true;
                return;
            }
            function playMusic() {
                if (isPlaying || !audioBuffer) return;
                sourceNode = audioContext.createBufferSource();
                sourceNode.buffer = audioBuffer;
                sourceNode.loop = true;
                sourceNode.connect(audioContext.destination);
                sourceNode.start();
                isPlaying = true;
                iconOn.style.display = 'inline';
                iconOff.style.display = 'none';
            }
            function stopMusic() {
                if (!isPlaying || !sourceNode) return;
                sourceNode.stop();
                sourceNode.disconnect();
                sourceNode = null;
                isPlaying = false;
                iconOn.style.display = 'none';
                iconOff.style.display = 'inline';
            }
            musicButton.addEventListener('click', (e) => {
                e.stopPropagation();
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                if (isPlaying) {
                    stopMusic();
                } else {
                    playMusic();
                }
            });
        }

        function setupFullscreen() {
            // This function remains the same as provided
            const prompt = document.getElementById('fullscreen-prompt');
            if (isTouchDevice) {
                setTimeout(() => { prompt.style.opacity = '1'; }, 2000);
                setTimeout(() => { prompt.style.opacity = '0'; }, 7000);
            }
            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement) {
                    if (screen.orientation && typeof screen.orientation.unlock === 'function') {
                        screen.orientation.unlock();
                    }
                }
            });
            renderer.domElement.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(() => {});
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            updateTankMovement();
            
            // Step the physics world
            world.step(1 / 60, deltaTime, 3);

            // Sync visual tank with physics body
            if(tankModel && tankBody) {
                tankModel.position.copy(tankBody.position);
                // Adjust position slightly if pivot point is not at the base
                tankModel.position.y -= 0.2; 
                tankModel.quaternion.copy(tankBody.quaternion);

                // Update camera pivot to follow the tank
                cameraPivot.position.copy(tankBody.position);
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>
