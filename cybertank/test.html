<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tank Physics Demo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
        }

        #fullscreen-prompt {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 20px;
            font-family: sans-serif;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 10;
        }

        #music-toggle-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            z-index: 100;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        #music-toggle-btn:hover {
            opacity: 1;
        }

        #music-toggle-btn svg {
            display: block;
        }

        /* 摇杆样式 */
        #joystick-container {
            position: absolute;
            bottom: 30px;
            left: 50px;
            width: 120px;
            height: 120px;
            z-index: 10;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.149.0/examples/jsm/",
                "@dimforge/rapier3d-compat": "https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.11.2/dist/rapier.es.js"
            }
        }
    </script>
    <!-- NippleJS for Joystick -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
</head>

<body>
    <div id="joystick-container"></div>
    <div id="fullscreen-prompt">Tap to enter fullscreen & lock landscape</div>
    <button id="music-toggle-btn" aria-label="Toggle Music">
        <span id="music-icon-on" style="display: none;">
            <svg xmlns="http://www.w3.org/2000/svg" height="32px" viewBox="0 0 24 24" width="32px" fill="#76FF33"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M12 3v9.28c-.47-.17-.97-.28-1.5-.28C8.01 12 6 14.01 6 16.5S8.01 21 10.5 21c2.31 0 4.2-1.75 4.45-4H15V6h4V3h-7zM10.5 19c-1.38 0-2.5-1.12-2.5-2.5S9.12 14 10.5 14s2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>
        </span>
        <span id="music-icon-off">
            <svg xmlns="http://www.w3.org/2000/svg" height="32px" viewBox="0 0 24 24" width="32px" fill="#76FF33"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M4.27 3L3 4.27l9 9v.28c-.47-.17-.97-.28-1.5-.28C8.01 13.5 6 15.51 6 18s2.01 4.5 4.5 4.5S15 20.49 15 18v-1.73L19.73 21 21 19.73 4.27 3zM10.5 19.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5 2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zM12 10.15v-7.1h4V6h-4v2.87l2.13 2.13z"/></svg>
        </span>
    </button>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
        import RAPIER from '@dimforge/rapier3d-compat';

        let scene, camera, renderer, world;
        let tankModel, tankBody;
        let physicsObjects = [];

        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        let audioContext, audioBuffer, sourceNode, isPlaying = false;

        // --- Control State ---
        const moveDirection = { forward: 0, turn: 0 };
        const cameraAngle = { horizontal: Math.PI, vertical: 0.4 }; // Initial 180 deg horizontal
        const cameraOffset = new THREE.Vector3(0, 4, 12);
        const moveForce = 250;
        const turnTorque = 150;


        init();

        async function init() {
            // --- Physics Initialization ---
            await RAPIER.init();
            const gravity = { x: 0.0, y: -9.81, z: 0.0 };
            world = new RAPIER.World(gravity);

            // --- Basic Three.js Scene Setup ---
            scene = new THREE.Scene();
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffeeb1, 1);
            directionalLight.position.set(-20, 30, 20);
            scene.add(directionalLight);

            // --- Load Assets and Setup Controls ---
            loadAssetsAndPhysics();
            setupControls();
            setupMusicControls();
            setupFullscreen();

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // --- Asset Loading and Physics Body Creation ---
        function loadAssetsAndPhysics() {
            const exrLoader = new EXRLoader();
            const gltfLoader = new GLTFLoader();

            exrLoader.load('assets/Minigame_Synth_Environment_4096x2048.exr', (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.environment = texture;

                // Load Scene first
                gltfLoader.load('assets/Minigame_Synth_Scene.glb', (gltf) => {
                    const sceneModel = gltf.scene;
                    scene.add(sceneModel);

                    // Create static physics body for the scene
                    sceneModel.traverse(child => {
                        if (child.isMesh) {
                            child.receiveShadow = true;
                            createTrimeshCollider(child, RAPIER.RigidBodyDesc.fixed());
                        }
                    });

                    // Load Tank after scene is loaded
                    gltfLoader.load('assets/Minigame_Synth_Tank.glb', (gltf) => {
                        tankModel = gltf.scene;
                        tankModel.position.set(0, 2, 0); // Start slightly above ground
                        scene.add(tankModel);

                        // Create dynamic physics body for the tank
                        const bodyDesc = RAPIER.RigidBodyDesc.dynamic()
                            .setTranslation(tankModel.position.x, tankModel.position.y, tankModel.position.z)
                            .setLinearDamping(0.5)
                            .setAngularDamping(0.8);
                        tankBody = world.createRigidBody(bodyDesc);
                        
                        tankModel.traverse(child => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                createTrimeshCollider(child, null, tankBody); // Attach colliders to tank's body
                            }
                        });
                    });
                });
            });
        }

        function createTrimeshCollider(mesh, bodyDesc, parentBody = null) {
            const geometry = mesh.geometry;
            const vertices = geometry.attributes.position.array;
            const indices = geometry.index.array;
            
            // Create the Trimesh collider description
            const trimeshDesc = RAPIER.ColliderDesc.trimesh(vertices, indices);
            
            if (bodyDesc) { // If a body description is provided, create a new rigid body
                const body = world.createRigidBody(bodyDesc);
                world.createCollider(trimeshDesc, body);
            } else if (parentBody) { // If a parent body is provided, attach the collider to it
                 world.createCollider(trimeshDesc, parentBody);
            }
        }

        // --- Controls Setup ---
        function setupControls() {
            // Joystick for mobile
            if (isTouchDevice) {
                const joystickManager = nipplejs.create({
                    zone: document.getElementById('joystick-container'),
                    mode: 'static',
                    position: { left: '80px', bottom: '80px' },
                    color: 'rgba(255,255,255,0.5)'
                });

                joystickManager.on('move', (evt, data) => {
                    const angle = data.angle.radian;
                    const force = data.force;
                    moveDirection.forward = Math.sin(angle) * force;
                    // NippleJS angle is weird, need to adjust for intuitive control
                    if (data.direction) {
                       if (data.direction.y === 'up') moveDirection.forward = force;
                       else if(data.direction.y === 'down') moveDirection.forward = -force * 0.7; // Slower reverse

                       if (data.direction.x === 'left') moveDirection.turn = force;
                       else if (data.direction.x === 'right') moveDirection.turn = -force;
                    } else {
                       moveDirection.forward = 0;
                       moveDirection.turn = 0;
                    }

                });

                joystickManager.on('end', () => {
                    moveDirection.forward = 0;
                    moveDirection.turn = 0;
                });
            }

            // Keyboard for Desktop
            document.addEventListener('keydown', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w': case 'arrowup':    moveDirection.forward = 1; break;
                    case 's': case 'arrowdown':  moveDirection.forward = -0.7; break;
                    case 'a': case 'arrowleft':  moveDirection.turn = 1; break;
                    case 'd': case 'arrowright': moveDirection.turn = -1; break;
                }
            });
             document.addEventListener('keyup', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w': case 'arrowup':    if(moveDirection.forward > 0) moveDirection.forward = 0; break;
                    case 's': case 'arrowdown':  if(moveDirection.forward < 0) moveDirection.forward = 0; break;
                    case 'a': case 'arrowleft':  if(moveDirection.turn > 0) moveDirection.turn = 0; break;
                    case 'd': case 'arrowright': if(moveDirection.turn < 0) moveDirection.turn = 0; break;
                }
            });


            // Camera orbit controls (mouse/touch)
            let isDragging = false;
            let prevMousePos = { x: 0, y: 0 };
            const rotationSpeed = 0.005;

            const onPointerDown = (e) => {
                 // Prevent camera move when interacting with UI
                if (e.target.id === 'music-toggle-btn' || e.target.closest('#joystick-container')) return;
                isDragging = true;
                prevMousePos.x = e.clientX || e.touches[0].clientX;
                prevMousePos.y = e.clientY || e.touches[0].clientY;
            };

            const onPointerMove = (e) => {
                if (!isDragging) return;
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                const deltaX = clientX - prevMousePos.x;
                const deltaY = clientY - prevMousePos.y;

                cameraAngle.horizontal -= deltaX * rotationSpeed;
                cameraAngle.vertical -= deltaY * rotationSpeed;
                cameraAngle.vertical = Math.max(-Math.PI / 4, Math.min(Math.PI / 2.5, cameraAngle.vertical)); // Clamp vertical angle

                prevMousePos.x = clientX;
                prevMousePos.y = clientY;
            };

            const onPointerUp = () => {
                isDragging = false;
            };

            renderer.domElement.addEventListener('mousedown', onPointerDown);
            renderer.domElement.addEventListener('mousemove', onPointerMove);
            renderer.domElement.addEventListener('mouseup', onPointerUp);
            renderer.domElement.addEventListener('mouseleave', onPointerUp);
            renderer.domElement.addEventListener('touchstart', onPointerDown, { passive: true });
            renderer.domElement.addEventListener('touchmove', onPointerMove, { passive: true });
            renderer.domElement.addEventListener('touchend', onPointerUp);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Step the physics world
            world.step();

            if (tankBody && tankModel) {
                // Apply forces to the tank based on input
                const tankRotation = tankBody.rotation();
                const tankQuaternion = new THREE.Quaternion(tankRotation.x, tankRotation.y, tankRotation.z, tankRotation.w);
                
                // Forward/backward force
                const forwardDir = new THREE.Vector3(0, 0, -1).applyQuaternion(tankQuaternion);
                tankBody.applyImpulse(forwardDir.multiplyScalar(moveDirection.forward * moveForce * 0.1), true);

                // Turning torque
                const upVec = new THREE.Vector3(0, 1, 0);
                tankBody.applyTorqueImpulse(upVec.multiplyScalar(moveDirection.turn * turnTorque * 0.1), true);


                // Update the Three.js model from the physics body
                const position = tankBody.translation();
                tankModel.position.set(position.x, position.y, position.z);
                tankModel.quaternion.set(tankRotation.x, tankRotation.y, tankRotation.z, tankRotation.w);

                // Update camera to follow and orbit the tank
                const rotatedOffset = cameraOffset.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngle.horizontal);
                
                // Apply vertical rotation
                const horizontalAxis = new THREE.Vector3(0, 1, 0).cross(rotatedOffset).normalize();
                rotatedOffset.applyAxisAngle(horizontalAxis, cameraAngle.vertical);

                const cameraTargetPosition = tankModel.position.clone().add(rotatedOffset);
                camera.position.lerp(cameraTargetPosition, 0.1); // Smooth follow

                // Always look at the tank's center
                const lookAtTarget = tankModel.position.clone().add(new THREE.Vector3(0, 1.5, 0)); // Look slightly above the base
                camera.lookAt(lookAtTarget);
            }

            renderer.render(scene, camera);
        };
        
        // --- Utility and UI Functions (mostly unchanged) ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
        
        function handleFullscreenRequest() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen()
                    .then(() => { if (isTouchDevice && screen.orientation && typeof screen.orientation.lock === 'function') { screen.orientation.lock('landscape').catch(() => {}); } })
                    .catch(() => {});
            }
        }

        function setupFullscreen() {
            const prompt = document.getElementById('fullscreen-prompt');
            if (isTouchDevice) {
                setTimeout(() => { prompt.style.opacity = '1'; }, 2000);
                setTimeout(() => { prompt.style.opacity = '0'; }, 7000);
                renderer.domElement.addEventListener('click', (e) => {
                     if (e.target.closest('#joystick-container')) return;
                     handleFullscreenRequest();
                });
            } else {
                 renderer.domElement.addEventListener('click', handleFullscreenRequest);
            }
             document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement) { if (screen.orientation && typeof screen.orientation.unlock === 'function') { screen.orientation.unlock(); } }
            });
        };

        async function setupMusicControls() {
            const musicButton = document.getElementById('music-toggle-btn');
            const iconOn = document.getElementById('music-icon-on');
            const iconOff = document.getElementById('music-icon-off');

            try {
                const response = await fetch('assets/bounce tanki loop cut (no intro).opus');
                const arrayBuffer = await response.arrayBuffer();
                audioContext = THREE.AudioContext.getContext();
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            } catch (error) {
                console.error('Failed to load or decode audio file:', error);
                musicButton.disabled = true;
                return;
            }

            function playMusic() {
                if (isPlaying || !audioBuffer) return;
                sourceNode = audioContext.createBufferSource();
                sourceNode.buffer = audioBuffer;
                sourceNode.loop = true;
                sourceNode.connect(audioContext.destination);
                sourceNode.start();
                isPlaying = true;
                iconOn.style.display = 'inline';
                iconOff.style.display = 'none';
            }

            function stopMusic() {
                if (!isPlaying || !sourceNode) return;
                sourceNode.stop();
                sourceNode.disconnect();
                sourceNode = null;
                isPlaying = false;
                iconOn.style.display = 'none';
                iconOff.style.display = 'inline';
            }

            musicButton.addEventListener('click', (e) => {
                e.stopPropagation();
                if (audioContext.state === 'suspended') { audioContext.resume(); }
                if (isPlaying) { stopMusic(); } else { playMusic(); }
            });
        }
    </script>
</body>

</html>
