<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Synth Tank Minigame</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        /* 摇杆的容器 */
        #joystick-zone {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div id="joystick-zone"></div>

    <!-- 库依赖 -->
    <!-- Three.js核心库 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
    <!-- GLB模型加载器 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- EXR环境贴图加载器 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/examples/js/loaders/EXRLoader.js"></script>
    <!-- 物理引擎 cannon-es -->
    <script type="importmap">
        {
            "imports": {
                "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
    <!-- 虚拟摇杆库 -->
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.1/dist/nipplejs.min.js"></script>


    <script type="module">
        import * as CANNON from 'cannon-es';

        let scene, camera, renderer;
        let world; // 物理世界
        let tankBody, tankModel; // 坦克的物理实体和3D模型
        const clock = new THREE.Clock();
        let joystickData = { x: 0, z: 0 }; // 摇杆输入

        // 辅助函数：将Three.js的Geometry转换为Cannon.js的Trimesh
        function createCannonTrimesh(geometry) {
            const vertices = geometry.attributes.position.array;
            const indices = geometry.index ? geometry.index.array : undefined;

            if (!indices) {
                // 如果模型没有索引（non-indexed），我们需要手动创建
                const newIndices = [];
                for (let i = 0; i < vertices.length / 3; i++) {
                    newIndices.push(i);
                }
                return new CANNON.Trimesh(vertices, newIndices);
            }
            return new CANNON.Trimesh(vertices, indices);
        }

        function init() {
            // 1. 场景设置
            scene = new THREE.Scene();

            // 2. 渲染器设置
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // 优化HDR效果
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.shadowMap.enabled = true; // 开启阴影
            document.body.appendChild(renderer.domElement);

            // 3. 相机设置
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20); // 初始相机位置

            // 4. 物理世界设置
            world = new CANNON.World();
            world.gravity.set(0, -20, 0); // 设置重力，-20让掉落感更明显
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.allowSleep = true;

            // 5. 光照和环境贴图
            const exrLoader = new THREE.EXRLoader();
            exrLoader.load('assets/Minigame_Synth_Environment_4096x2048.exr', (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.environment = texture;
            });

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffeeb1, 1);
            directionalLight.position.set(-20, 30, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // 6. 加载模型
            loadModels();

            // 7. 设置摇杆
            setupJoystick();
            
            // 8. 监听窗口大小变化
            window.addEventListener('resize', onWindowResize);
        }

        function loadModels() {
            const loader = new THREE.GLTFLoader();

            // 加载场景模型 (赛道)
            loader.load('assets/Minigame_Synth_Scene.glb', (gltf) => {
                const sceneModel = gltf.scene;
                scene.add(sceneModel);

                // 为场景创建物理实体
                sceneModel.traverse((child) => {
                    if (child.isMesh) {
                        child.receiveShadow = true; // 接收阴影
                        // 为每个mesh创建静态的物理三角网格
                        const sceneShape = createCannonTrimesh(child.geometry);
                        const sceneBody = new CANNON.Body({ mass: 0 }); // 质量为0表示静态
                        sceneBody.addShape(sceneShape);
                        sceneBody.position.copy(child.position);
                        sceneBody.quaternion.copy(child.quaternion);
                        world.addBody(sceneBody);
                    }
                });
            });

            // 加载坦克模型
            loader.load('assets/Minigame_Synth_Tank.glb', (gltf) => {
                tankModel = gltf.scene;
                tankModel.scale.set(1, 1, 1); // 根据需要调整大小
                scene.add(tankModel);

                tankModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true; // 投射阴影
                    }
                });
                
                // 为坦克创建物理实体 (使用简化的盒子形状以提高性能)
                const boundingBox = new THREE.Box3().setFromObject(tankModel);
                const size = new THREE.Vector3();
                boundingBox.getSize(size);
                const tankShape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
                
                tankBody = new CANNON.Body({
                    mass: 50, // 坦克质量
                    position: new CANNON.Vec3(0, 5, 0), // 初始位置，让它从空中掉落到赛道上
                    shape: tankShape,
                    material: new CANNON.Material({ friction: 0.1, restitution: 0.1 })
                });

                world.addBody(tankBody);
            });
        }
        
        function setupJoystick() {
            const options = {
                zone: document.getElementById('joystick-zone'),
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: 'cyan',
                size: 150
            };
            const manager = nipplejs.create(options);

            manager.on('move', (evt, data) => {
                if (data.angle) {
                    // 将摇杆的角度和力度转换为坦克的移动方向
                    const angle = data.angle.radian;
                    const force = data.force;
                    // 注意 three.js/cannon.js 的坐标系，z轴是向前的
                    joystickData.x = Math.cos(angle) * force;
                    joystickData.z = -Math.sin(angle) * force; // Z轴反向
                }
            });

            manager.on('end', () => {
                joystickData.x = 0;
                joystickData.z = 0;
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            // 更新物理世界
            world.step(1 / 60, deltaTime, 3);

            if (tankBody && tankModel) {
                // 1. 更新坦克的物理状态
                const speed = 150; // 移动速度系数
                const velocity = new CANNON.Vec3(joystickData.x * speed, tankBody.velocity.y, joystickData.z * speed);
                tankBody.velocity.x = velocity.x;
                tankBody.velocity.z = velocity.z;

                // 2. 更新坦克模型的朝向
                if (joystickData.x !== 0 || joystickData.z !== 0) {
                    const targetAngle = Math.atan2(joystickData.x, joystickData.z);
                    // 使用四元数进行平滑旋转
                    const targetQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetAngle);
                    tankModel.quaternion.slerp(targetQuaternion, 0.1);
                }
                
                // 3. 将物理实体的位置和旋转同步到3D模型
                tankModel.position.copy(tankBody.position);
                tankModel.quaternion.copy(tankBody.quaternion);

                // 4. 更新相机，使其跟随坦克
                const offset = new THREE.Vector3(0, 5, 10); // 相机在坦克后上方
                const cameraPosition = tankModel.position.clone().add(offset.applyQuaternion(tankModel.quaternion));
                camera.position.lerp(cameraPosition, 0.1); // 平滑过渡
                camera.lookAt(tankModel.position);
            }

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
