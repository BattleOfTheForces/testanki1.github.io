<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Synth Tank Minigame</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        #joystick-zone {
            position: absolute;
            bottom: 30px;
            left: 80px;
            width: 150px;
            height: 150px;
        }
    </style>

    <!-- 
      修正部分: 使用 importmap 统一管理所有模块
      - "three": 指向 Three.js 核心模块
      - "three/addons/": 是一个路径映射，它能让我们方便地加载所有 'examples/jsm/' 目录下的附加组件，如加载器、控制器等。
      - "cannon-es": 指向物理引擎模块
    -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.149.0/examples/jsm/",
                "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>
    <div id="joystick-zone"></div>

    <!-- nipplejs 是一个 UMD 库，可以像这样单独加载，它会创建一个全局的 nipplejs 对象 -->
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.1/dist/nipplejs.min.js"></script>

    <script type="module">
        // 修正部分: 从 importmap 定义的别名中导入模块
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
        import * as CANNON from 'cannon-es';

        let scene, camera, renderer;
        let world;
        let tankBody, tankModel;
        const clock = new THREE.Clock();
        let joystickData = { x: 0, z: 0 };

        function createCannonTrimesh(geometry) {
            const vertices = geometry.attributes.position.array;
            const indices = geometry.index ? geometry.index.array : Array.from({ length: vertices.length / 3 }, (_, i) => i);
            return new CANNON.Trimesh(vertices, indices);
        }

        function init() {
            scene = new THREE.Scene();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);

            world = new CANNON.World({
                gravity: new CANNON.Vec3(0, -20, 0),
                broadphase: new CANNON.SAPBroadphase(world)
            });
            world.allowSleep = true;

            const exrLoader = new EXRLoader();
            exrLoader.load('assets/Minigame_Synth_Environment_4096x2048.exr', (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.environment = texture;
            });

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffeeb1, 1);
            directionalLight.position.set(-20, 30, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            loadModels();
            setupJoystick();
            
            window.addEventListener('resize', onWindowResize);
        }

        function loadModels() {
            const loader = new GLTFLoader();

            loader.load('assets/Minigame_Synth_Scene.glb', (gltf) => {
                const sceneModel = gltf.scene;
                scene.add(sceneModel);

                sceneModel.traverse((child) => {
                    if (child.isMesh) {
                        child.receiveShadow = true;
                        const sceneShape = createCannonTrimesh(child.geometry);
                        const sceneBody = new CANNON.Body({ mass: 0 });
                        sceneBody.addShape(sceneShape, child.position, child.quaternion);
                        world.addBody(sceneBody);
                    }
                });
            });

            loader.load('assets/Minigame_Synth_Tank.glb', (gltf) => {
                tankModel = gltf.scene;
                tankModel.scale.set(1, 1, 1);
                scene.add(tankModel);

                tankModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                    }
                });
                
                const boundingBox = new THREE.Box3().setFromObject(tankModel);
                const size = new THREE.Vector3();
                boundingBox.getSize(size);
                const tankShape = new CANNON.Box(new CANNON.Vec3(size.x * 0.5, size.y * 0.5, size.z * 0.5));
                
                tankBody = new CANNON.Body({
                    mass: 50,
                    position: new CANNON.Vec3(0, 5, 0),
                    shape: tankShape,
                    material: new CANNON.Material({ friction: 0.1, restitution: 0.1 }),
                    angularDamping: 0.9, // 增加角阻尼，防止坦克轻易翻滚
                    linearDamping: 0.5 // 增加线性阻尼，让停止更自然
                });

                world.addBody(tankBody);
            });
        }
        
        function setupJoystick() {
            const options = {
                zone: document.getElementById('joystick-zone'),
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: 'cyan',
                size: 150,
                restJoystick: true
            };
            const manager = nipplejs.create(options);

            manager.on('move', (evt, data) => {
                if (data.angle) {
                    const angle = data.angle.radian;
                    const force = data.force;
                    joystickData.x = Math.cos(angle) * force;
                    joystickData.z = -Math.sin(angle) * force;
                }
            });

            manager.on('end', () => {
                joystickData.x = 0;
                joystickData.z = 0;
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = Math.min(clock.getDelta(), 0.1);
            world.step(1 / 60, deltaTime, 3);

            if (tankBody && tankModel) {
                const moveSpeed = 20; // 调整移动速度
                const turnSpeed = 4;   // 调整转向速度

                // 更新坦克物理状态
                const forward = new CANNON.Vec3(0, 0, -1);
                const controlVector = new CANNON.Vec3(joystickData.x, 0, joystickData.z);

                if (controlVector.length() > 0.1) {
                     // 移动
                    const force = controlVector.z * moveSpeed;
                    const worldForce = tankBody.quaternion.vmult(new CANNON.Vec3(0, 0, force));
                    tankBody.velocity.x = worldForce.x * moveSpeed;
                    tankBody.velocity.z = worldForce.z * moveSpeed;
                    
                    // 转向
                    const turn = controlVector.x * -turnSpeed;
                    tankBody.angularVelocity.y = turn;
                } else {
                    // 停止时减速
                    tankBody.angularVelocity.y *= 0.8;
                }

                // 将物理实体的位置和旋转同步到3D模型
                tankModel.position.copy(tankBody.position);
                tankModel.quaternion.copy(tankBody.quaternion);

                // 更新相机，使其跟随坦克
                const offset = new THREE.Vector3(0, 6, 12);
                const cameraPosition = new THREE.Vector3().copy(tankBody.position);
                const offsetRotated = offset.clone().applyQuaternion(tankBody.quaternion);
                cameraPosition.add(offsetRotated);

                camera.position.lerp(cameraPosition, 0.1);
                camera.lookAt(tankModel.position);
            }

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
