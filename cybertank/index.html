<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Synth Tank Minigame</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #joystick-zone {
            position: absolute;
            bottom: 30px;
            left: 80px;
            width: 150px;
            height: 150px;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.149.0/examples/jsm/",
                "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>
    <div id="joystick-zone"></div>

    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.1/dist/nipplejs.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // --- 核心修正 1: 导入 BufferGeometryUtils ---
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        import * as CANNON from 'cannon-es';

        let scene, camera, renderer, controls;
        let world;
        let tankBody, tankModel;
        const clock = new THREE.Clock();
        let joystickData = { x: 0, z: 0 };

        function createCannonTrimesh(geometry) {
            if (!geometry.index) {
                // cannon-es Trimesh 需要索引
                const indices = Array.from({ length: geometry.attributes.position.count / 3 }, (_, i) => [i * 3, i * 3 + 1, i * 3 + 2]).flat();
                geometry.setIndex(indices);
            }
            const vertices = geometry.attributes.position.array;
            const indices = geometry.index.array;
            return new CANNON.Trimesh(vertices, indices);
        }

        function init() {
            scene = new THREE.Scene();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enablePan = false;
            controls.maxPolarAngle = Math.PI / 2 - 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 50;

            world = new CANNON.World({
                gravity: new CANNON.Vec3(0, -20, 0),
                broadphase: new CANNON.SAPBroadphase(world)
            });
            world.allowSleep = true;

            const exrLoader = new EXRLoader();
            exrLoader.load('assets/Minigame_Synth_Environment_4096x2048.exr', (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.environment = texture;
            });

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffeeb1, 1);
            directionalLight.position.set(-20, 30, 20);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            loadModels();
            setupJoystick();
            
            window.addEventListener('resize', onWindowResize);
        }

        function loadModels() {
            const loader = new GLTFLoader();

            // --- 核心修正 2: 使用合并几何体的方法创建场景物理实体 ---
            loader.load('assets/Minigame_Synth_Scene.glb', (gltf) => {
                const sceneModel = gltf.scene;
                scene.add(sceneModel);

                const geometriesToMerge = [];
                sceneModel.traverse((child) => {
                    if (child.isMesh) {
                        child.receiveShadow = true;
                        
                        // 关键步骤: 创建几何体的副本，并应用其世界变换矩阵
                        // 这会将每个小部件的顶点位置从局部坐标转换到世界坐标
                        const geo = child.geometry.clone();
                        geo.applyMatrix4(child.matrixWorld);
                        
                        geometriesToMerge.push(geo);
                    }
                });

                if (geometriesToMerge.length > 0) {
                    // 使用工具库将所有几何体合并成一个
                    const mergedGeometry = BufferGeometryUtils.mergeGeometries(geometriesToMerge, false);
                    
                    // 为这个合并后的巨大几何体创建一个单一的、精确的物理外壳
                    const sceneShape = createCannonTrimesh(mergedGeometry);
                    
                    const sceneBody = new CANNON.Body({ mass: 0 }); // 质量为0的静态物体
                    sceneBody.addShape(sceneShape);
                    // 因为顶点已经是世界坐标，所以物体本身放在原点即可
                    sceneBody.position.set(0, 0, 0); 
                    sceneBody.quaternion.set(0, 0, 0, 1);
                    
                    world.addBody(sceneBody);
                }
            });

            // 坦克加载逻辑保持不变
            loader.load('assets/Minigame_Synth_Tank.glb', (gltf) => {
                tankModel = gltf.scene;
                scene.add(tankModel);

                tankModel.traverse((child) => { if (child.isMesh) child.castShadow = true; });
                
                const boundingBox = new THREE.Box3().setFromObject(tankModel);
                const size = new THREE.Vector3();
                boundingBox.getSize(size);
                const tankShape = new CANNON.Box(new CANNON.Vec3(size.x * 0.5, size.y * 0.5, size.z * 0.5));
                
                tankBody = new CANNON.Body({
                    mass: 50,
                    position: new CANNON.Vec3(0, 5, 0),
                    shape: tankShape,
                    angularDamping: 0.95, 
                    linearDamping: 0.5 
                });
                world.addBody(tankBody);
            });
        }
        
        function setupJoystick() {
            // ... (此部分无变化)
            const options = { zone: document.getElementById('joystick-zone'), mode: 'static', position: { left: '50%', top: '50%' }, color: 'cyan', size: 150, restJoystick: true };
            const manager = nipplejs.create(options);
            manager.on('move', (evt, data) => { if (data.angle) { const angle = data.angle.radian; const force = data.force; joystickData.x = Math.cos(angle) * force; joystickData.z = -Math.sin(angle) * force; } });
            manager.on('end', () => { joystickData.x = 0; joystickData.z = 0; });
        }
        
        function onWindowResize() {
            // ... (此部分无变化)
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = Math.min(clock.getDelta(), 0.1);
            world.step(1 / 60, deltaTime, 3);

            if (tankBody && tankModel) {
                // ... (此部分无变化)
                const moveSpeed = 20; 
                const turnSpeed = 4;   
                const controlVector = new CANNON.Vec3(joystickData.x, 0, joystickData.z);
                if (controlVector.length() > 0.1) {
                    const force = controlVector.z * moveSpeed;
                    const worldForce = tankBody.quaternion.vmult(new CANNON.Vec3(0, 0, force));
                    tankBody.velocity.x = worldForce.x * moveSpeed;
                    tankBody.velocity.z = worldForce.z * moveSpeed;
                    const turn = controlVector.x * -turnSpeed;
                    tankBody.angularVelocity.y = turn;
                } else {
                    tankBody.angularVelocity.y *= 0.8;
                }
                tankModel.position.copy(tankBody.position);
                tankModel.quaternion.copy(tankBody.quaternion);

                controls.target.copy(tankModel.position);
                controls.update();
            }
            
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
