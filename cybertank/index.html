<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Synth Tank Showcase - Free Camera</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #fullscreen-prompt { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: white; background-color: rgba(0, 0, 0, 0.5); padding: 8px 15px; border-radius: 20px; font-family: sans-serif; font-size: 14px; pointer-events: none; opacity: 0; transition: opacity 0.5s; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.149.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="fullscreen-prompt">Tap to enter fullscreen</div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
        // OrbitControls 不再是必须的，我们自己写控制逻辑

        let scene, camera, renderer;
        const loader = new GLTFLoader();

        init();
        animate();

        function init() {
            scene = new THREE.Scene();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);

            // --- 核心改动 1: 设置自由相机控制器 ---
            setupFreeCameraControls();

            const exrLoader = new EXRLoader();
            exrLoader.load('assets/Minigame_Synth_Environment_4096x2048.exr', (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.environment = texture;
            });

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffeeb1, 1);
            directionalLight.position.set(-20, 30, 20);
            scene.add(directionalLight);

            loadModels();
            setupFullscreen();
            window.addEventListener('resize', onWindowResize);
        }

        function loadModels() {
            loader.load('assets/Minigame_Synth_Scene.glb', (gltf) => {
                scene.add(gltf.scene);
            });

            loader.load('assets/Minigame_Synth_Tank.glb', (gltf) => {
                const tankModel = gltf.scene;
                tankModel.position.set(0, 0.2, 0);
                
                // --- 核心改动 2: 旋转坦克模型 ---
                // 围绕Y轴旋转180度 (PI 弧度)
                tankModel.rotation.y = Math.PI; 
                
                scene.add(tankModel);
            });
        }

        function setupFreeCameraControls() {
            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            const moveSpeed = 0.05;
            let startX, startY, prevPinchDist = 0;
            let isDragging = false;
            let touchCount = 0;

            function onPointerDown(event) {
                isDragging = true;
                touchCount = event.touches ? event.touches.length : 1;

                if (touchCount === 1) {
                    startX = event.touches ? event.touches[0].clientX : event.clientX;
                    startY = event.touches ? event.touches[0].clientY : event.clientY;
                } else if (touchCount === 2) {
                    const dx = event.touches[0].clientX - event.touches[1].clientX;
                    const dy = event.touches[0].clientY - event.touches[1].clientY;
                    prevPinchDist = Math.sqrt(dx * dx + dy * dy);
                }
            }

            function onPointerMove(event) {
                if (!isDragging) return;

                touchCount = event.touches ? event.touches.length : 1;

                if (touchCount === 1) {
                    // 单指滑动：旋转视角
                    const currentX = event.touches ? event.touches[0].clientX : event.clientX;
                    const currentY = event.touches ? event.touches[0].clientY : event.clientY;
                    const deltaX = currentX - startX;
                    const deltaY = currentY - startY;

                    euler.setFromQuaternion(camera.quaternion);
                    euler.y -= deltaX * 0.002;
                    euler.x -= deltaY * 0.002;
                    euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x)); // 限制上下看的角度

                    camera.quaternion.setFromEuler(euler);
                    
                    startX = currentX;
                    startY = currentY;
                } else if (touchCount === 2) {
                    // 双指捏合：前后移动
                    const dx = event.touches[0].clientX - event.touches[1].clientX;
                    const dy = event.touches[0].clientY - event.touches[1].clientY;
                    const currentPinchDist = Math.sqrt(dx * dx + dy * dy);
                    const deltaPinch = currentPinchDist - prevPinchDist;

                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    camera.position.addScaledVector(forward, deltaPinch * moveSpeed * 0.1);

                    prevPinchDist = currentPinchDist;
                }
            }

            function onPointerUp(event) {
                isDragging = false;
                prevPinchDist = 0;
                touchCount = event.touches ? event.touches.length : 0;
            }

            const canvas = renderer.domElement;
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('pointerleave', onPointerUp); // 如果手指滑出屏幕也算结束
        }

        function setupFullscreen() { /* ... 此部分代码不变 ... */ }

        function onWindowResize() { /* ... 此部分代码不变 ... */ }

        function animate() {
            requestAnimationFrame(animate);
            // 这里不再需要 controls.update()
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
