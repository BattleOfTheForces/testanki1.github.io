<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Three.js Synth Tank</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        #joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            /* For better visibility on mobile */
            background: rgba(128, 128, 128, 0.2);
            border-radius: 50%;
        }
        /* A simple loading indicator */
        #loader {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: monospace;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div id="loader">Loading... 0%</div>
    <div id="joystick-container"></div>
    
    <!-- Libraries -->
    <!-- Three.js Core -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
                "nipplejs": "https://unpkg.com/nipplejs@0.10.1/dist/nipplejs.js"
            }
        }
    </script>

    <!-- Main Application Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';
        import nipplejs from 'nipplejs';

        // --- SCENE SETUP ---
        let scene, camera, renderer, clock, controls;
        let physicsWorld;
        let tank = { mesh: null, body: null };
        let sceneModel = { mesh: null, body: null };
        const objectsToUpdate = [];

        // --- CONTROL STATE ---
        const moveState = {
            forward: 0,
            right: 0
        };

        init();
        animate();

        function init() {
            // Loader Element
            const loadingManager = new THREE.LoadingManager();
            const loaderElement = document.getElementById('loader');
            loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
                const percent = Math.round((itemsLoaded / itemsTotal) * 100);
                loaderElement.textContent = `Loading... ${percent}%`;
            };
            loadingManager.onLoad = () => {
                loaderElement.style.display = 'none';
            };

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            // Scene
            scene = new THREE.Scene();
            clock = new THREE.Clock();

            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            // Controls (for debugging on desktop)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 1, 0);

            // Physics World
            physicsWorld = new CANNON.World({
                gravity: new CANNON.Vec3(0, -9.82, 0),
            });
            physicsWorld.broadphase = new CANNON.SAPBroadphase(physicsWorld);
            physicsWorld.allowSleep = true;

            // --- LOAD ASSETS ---
            const gltfLoader = new GLTFLoader(loadingManager);
            const exrLoader = new EXRLoader(loadingManager);

            // Environment
            exrLoader.load('assets/Minigame_Synth_Environment_4096x2048.exr', (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.environment = texture;
            });
            
            // Scene Model (The Track)
            gltfLoader.load('assets/Minigame_Synth_Scene.glb', (gltf) => {
                sceneModel.mesh = gltf.scene;
                scene.add(sceneModel.mesh);

                // Create static physics body from the model geometry
                sceneModel.mesh.traverse(child => {
                    if (child.isMesh) {
                        const vertices = child.geometry.attributes.position.array;
                        const indices = child.geometry.index ? child.geometry.index.array : undefined;
                        
                        const trimeshShape = new CANNON.Trimesh(vertices, indices);
                        const trimeshBody = new CANNON.Body({ mass: 0 }); // Mass 0 makes it static
                        trimeshBody.addShape(trimeshShape);
                        trimeshBody.position.copy(child.position);
                        trimeshBody.quaternion.copy(child.quaternion);
                        physicsWorld.addBody(trimeshBody);
                    }
                });
            });

            // Tank Model
            gltfLoader.load('assets/Minigame_Synth_Tank.glb', (gltf) => {
                tank.mesh = gltf.scene;
                scene.add(tank.mesh);

                // Create dynamic physics body (approximated as a box)
                const box = new THREE.Box3().setFromObject(tank.mesh);
                const size = new THREE.Vector3();
                box.getSize(size);
                const shape = new CANNON.Box(new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2));
                
                tank.body = new CANNON.Body({
                    mass: 5,
                    shape: shape,
                    position: new CANNON.Vec3(0, 3, 0), // Start slightly above the track
                    material: new CANNON.Material({ friction: 0.1, restitution: 0.1 }),
                });

                physicsWorld.addBody(tank.body);
                objectsToUpdate.push({ mesh: tank.mesh, body: tank.body });
            });
            
            // --- CONTROLS SETUP ---
            setupJoystick();

            // Window Resize
            window.addEventListener('resize', onWindowResize);
        }

        function setupJoystick() {
            const options = {
                zone: document.getElementById('joystick-container'),
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: 'cyan',
                size: 150
            };
            const manager = nipplejs.create(options);

            manager.on('move', (evt, data) => {
                const angle = data.angle.radian;
                const force = data.force;
                // Convert joystick angle/force to forward/right movement
                moveState.forward = -Math.sin(angle) * force;
                moveState.right = Math.cos(angle) * force;
            });

            manager.on('end', () => {
                moveState.forward = 0;
                moveState.right = 0;
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = Math.min(0.1, clock.getDelta());
            
            // Step the physics world
            physicsWorld.step(1 / 60, deltaTime);
            
            // Update Tank Movement
            if (tank.body && tank.mesh) {
                const moveSpeed = 8;
                const turnSpeed = 4;
                
                // Calculate movement vector based on camera's direction
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);
                cameraDirection.y = 0;
                cameraDirection.normalize();

                const rightDirection = new THREE.Vector3().crossVectors(camera.up, cameraDirection).normalize();
                
                const moveVector = new THREE.Vector3()
                    .addScaledVector(cameraDirection, moveState.forward)
                    .addScaledVector(rightDirection, moveState.right);
                    
                if (moveVector.length() > 0.01) {
                    // Apply velocity
                    const velocity = new CANNON.Vec3(
                        moveVector.x * moveSpeed,
                        tank.body.velocity.y, // Keep current y velocity (for gravity)
                        moveVector.z * moveSpeed
                    );
                    tank.body.velocity.copy(velocity);
                    
                    // Rotate the visual mesh to face the movement direction
                    const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), moveVector.normalize());
                    tank.mesh.quaternion.slerp(targetQuaternion, deltaTime * turnSpeed * 5);

                } else {
                    // Stop movement
                    tank.body.velocity.x = 0;
                    tank.body.velocity.z = 0;
                }
            }

            // Sync physics bodies with three.js meshes
            for (const object of objectsToUpdate) {
                object.mesh.position.copy(object.body.position);
                // We handle the tank's rotation manually for better control, so only copy physics rotation for other objects if needed.
                if (object !== tank) {
                   object.mesh.quaternion.copy(object.body.quaternion);
                }
            }

            // Update camera to follow the tank
            if (tank.mesh) {
                const offset = new THREE.Vector3(0, 5, 10);
                // Apply camera's rotation to the offset vector
                offset.applyQuaternion(camera.quaternion);
                const targetPosition = tank.mesh.position.clone().add(offset);
                
                camera.position.lerp(targetPosition, 0.05); // Smoothly move camera
                controls.target.lerp(tank.mesh.position, 0.05); // Smoothly update controls target
            }

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
