<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Synth Tank Minigame</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #joystick-zone {
            position: absolute;
            bottom: 30px;
            left: 80px;
            width: 150px;
            height: 150px;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.149.0/examples/jsm/",
                "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>
    <div id="joystick-zone"></div>

    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.1/dist/nipplejs.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
        // --- 修正部分 2A: 导入 OrbitControls ---
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';

        let scene, camera, renderer, controls; // 添加 controls 变量
        let world;
        let tankBody, tankModel;
        const clock = new THREE.Clock();
        let joystickData = { x: 0, z: 0 };

        function createCannonTrimesh(geometry) {
            const vertices = geometry.attributes.position.array;
            const indices = geometry.index ? geometry.index.array : Array.from({ length: vertices.length / 3 }, (_, i) => i);
            return new CANNON.Trimesh(vertices, indices);
        }

        function init() {
            scene = new THREE.Scene();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);

            // --- 修正部分 2B: 初始化 OrbitControls ---
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // 启用阻尼（惯性），使旋转更平滑
            controls.dampingFactor = 0.05;
            controls.enablePan = false; // 禁止右键平移
            controls.maxPolarAngle = Math.PI / 2 - 0.05; // 禁止相机旋转到地平线以下
            controls.minDistance = 5; // 最小缩放距离
            controls.maxDistance = 50; // 最大缩放距离

            world = new CANNON.World({
                gravity: new CANNON.Vec3(0, -20, 0),
                broadphase: new CANNON.SAPBroadphase(world)
            });
            world.allowSleep = true;

            const exrLoader = new EXRLoader();
            exrLoader.load('assets/Minigame_Synth_Environment_4096x2048.exr', (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.environment = texture;
            });

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffeeb1, 1);
            directionalLight.position.set(-20, 30, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            loadModels();
            setupJoystick();
            
            window.addEventListener('resize', onWindowResize);
        }

        function loadModels() {
            const loader = new GLTFLoader();

            // --- 修正部分 1: 修复场景碰撞 ---
            loader.load('assets/Minigame_Synth_Scene.glb', (gltf) => {
                const sceneModel = gltf.scene;
                scene.add(sceneModel);

                sceneModel.traverse((child) => {
                    if (child.isMesh) {
                        child.receiveShadow = true;
                        
                        // 创建物理形状
                        const sceneShape = createCannonTrimesh(child.geometry);
                        
                        // 创建一个静态物理实体 (mass: 0)
                        const sceneBody = new CANNON.Body({ mass: 0 });
                        
                        // 获取网格的世界坐标和旋转
                        const worldPosition = new THREE.Vector3();
                        const worldQuaternion = new THREE.Quaternion();
                        child.getWorldPosition(worldPosition);
                        child.getWorldQuaternion(worldQuaternion);

                        // 将物理实体的位置和旋转设置为世界坐标
                        sceneBody.position.copy(worldPosition);
                        sceneBody.quaternion.copy(worldQuaternion);
                        
                        // 将形状添加到实体中 (注意：这里不再需要偏移量)
                        sceneBody.addShape(sceneShape);
                        
                        world.addBody(sceneBody);
                    }
                });
            });


            loader.load('assets/Minigame_Synth_Tank.glb', (gltf) => {
                tankModel = gltf.scene;
                scene.add(tankModel);

                tankModel.traverse((child) => { if (child.isMesh) child.castShadow = true; });
                
                const boundingBox = new THREE.Box3().setFromObject(tankModel);
                const size = new THREE.Vector3();
                boundingBox.getSize(size);
                const tankShape = new CANNON.Box(new CANNON.Vec3(size.x * 0.5, size.y * 0.5, size.z * 0.5));
                
                tankBody = new CANNON.Body({
                    mass: 50,
                    position: new CANNON.Vec3(0, 5, 0),
                    shape: tankShape,
                    material: new CANNON.Material({ friction: 0.1, restitution: 0.1 }),
                    angularDamping: 0.95, 
                    linearDamping: 0.5 
                });

                world.addBody(tankBody);
            });
        }
        
        function setupJoystick() {
            const options = {
                zone: document.getElementById('joystick-zone'),
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: 'cyan', size: 150, restJoystick: true
            };
            const manager = nipplejs.create(options);

            manager.on('move', (evt, data) => {
                if (data.angle) {
                    const angle = data.angle.radian;
                    const force = data.force;
                    joystickData.x = Math.cos(angle) * force;
                    joystickData.z = -Math.sin(angle) * force;
                }
            });

            manager.on('end', () => {
                joystickData.x = 0; joystickData.z = 0;
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = Math.min(clock.getDelta(), 0.1);
            world.step(1 / 60, deltaTime, 3);

            if (tankBody && tankModel) {
                // ... (坦克移动逻辑保持不变)
                const moveSpeed = 20; 
                const turnSpeed = 4;   

                const controlVector = new CANNON.Vec3(joystickData.x, 0, joystickData.z);
                if (controlVector.length() > 0.1) {
                    const force = controlVector.z * moveSpeed;
                    const worldForce = tankBody.quaternion.vmult(new CANNON.Vec3(0, 0, force));
                    tankBody.velocity.x = worldForce.x * moveSpeed;
                    tankBody.velocity.z = worldForce.z * moveSpeed;
                    
                    const turn = controlVector.x * -turnSpeed;
                    tankBody.angularVelocity.y = turn;
                } else {
                    tankBody.angularVelocity.y *= 0.8;
                }

                tankModel.position.copy(tankBody.position);
                tankModel.quaternion.copy(tankBody.quaternion);

                // --- 修正部分 2C: 更新 OrbitControls ---
                // 将 OrbitControls 的目标设置为坦克的位置
                controls.target.copy(tankModel.position);
                // 更新控制器状态（应用用户的滑动、缩放等操作）
                controls.update();
            }
            
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
