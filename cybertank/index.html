        // --- REVISED: Loading Orchestrator ---
        async function startLoading() {
            const loadingOverlay = document.getElementById('loading-overlay');
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const loadingText = document.querySelector('#loading-container .loading-text'); // Get the text element

            // The global progress update function remains the same.
            function updateTotalProgress() {
                let totalLoaded = 0;
                for (const assetName in progressByAsset) {
                    totalLoaded += progressByAsset[assetName].loaded;
                }
                const percentage = TOTAL_BYTES > 0 ? (totalLoaded / TOTAL_BYTES) * 100 : 0;
                progressBar.style.width = `${percentage}%`;
                progressText.textContent = `${(totalLoaded / 1024 / 1024).toFixed(2)} MB / ${(TOTAL_BYTES / 1024 / 1024).toFixed(2)} MB`;
            }

            // The fetch helper function remains the same.
            async function fetchWithProgress(url, onProgress) {
                // ... (No changes to this function's implementation)
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const contentLength = +response.headers.get('Content-Length');
                if (!response.body) throw new Error('Response body is null');
                
                const reader = response.body.getReader();
                let receivedLength = 0;
                const chunks = [];
                while(true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    chunks.push(value);
                    receivedLength += value.length;
                    if (onProgress) onProgress({ loaded: receivedLength, total: contentLength });
                }
                const allChunks = new Uint8Array(receivedLength);
                let position = 0;
                for(let chunk of chunks) {
                    allChunks.set(chunk, position);
                    position += chunk.length;
                }
                return allChunks.buffer;
            }
            
            updateTotalProgress();

            const gltfLoader = new GLTFLoader();
            const exrLoader = new EXRLoader();
            const promises = {}; // Use an object to store promises by name
            const loadedData = {};

            // 1. Start ALL downloads in parallel
            ASSETS_TO_LOAD.forEach(asset => {
                const onProgress = (progress) => {
                    progressByAsset[asset.name].loaded = progress.loaded;
                    updateTotalProgress();
                };
                
                const promise = new Promise((resolve, reject) => {
                    const onLoad = (result) => {
                        progressByAsset[asset.name].loaded = progressByAsset[asset.name].total;
                        updateTotalProgress();
                        loadedData[asset.name] = result;
                        resolve(result); // Resolve with the data
                    };

                    if (asset.type === 'gltf') gltfLoader.load(asset.url, onLoad, onProgress, reject);
                    else if (asset.type === 'exr') exrLoader.load(asset.url, onLoad, onProgress, reject);
                    else if (asset.type === 'audio') fetchWithProgress(asset.url, onProgress).then(onLoad).catch(reject);
                });
                
                promises[asset.name] = promise;
            });
            
            // 2. Create an async function to update UI text sequentially
            async function manageLoadingUI() {
                for (const asset of ASSETS_TO_LOAD) {
                    loadingText.textContent = `正在加载 ${asset.displayName}...`;
                    await promises[asset.name]; // Wait for this specific, already-running promise
                }
                loadingText.textContent = '准备进入场景...';
            }

            // 3. Run UI management and final setup logic concurrently
            try {
                // Start the UI manager
                manageLoadingUI(); 
                
                // Wait for ALL promises to complete before setting up the scene
                await Promise.all(Object.values(promises));

                setTimeout(() => {
                    loadingOverlay.style.opacity = '0';
                    loadingOverlay.addEventListener('transitionend', () => loadingOverlay.remove(), { once: true });

                    // Setup scene with all loaded assets
                    setupPhysics(loadedData.sceneModel, loadedData.tankModel);
                    initializeMusicPlayer(loadedData.music);

                }, 500); // Small delay to appreciate the 100% bar
            } catch (error) {
                console.error("An error occurred during asset loading:", error);
                loadingText.textContent = '资源加载失败，请刷新页面。';
                progressBar.style.backgroundColor = 'red';
            }
        }
