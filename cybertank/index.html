<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Synth Tank Minigame (with Physics Debugger)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #joystick-zone { position: absolute; bottom: 30px; left: 80px; width: 150px; height: 150px; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.149.0/examples/jsm/",
                "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>
    <div id="joystick-zone"></div>
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.1/dist/nipplejs.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        import * as CANNON from 'cannon-es';

        // --- 核心调试工具: CannonDebugger ---
        class CannonDebugger {
            constructor(scene, world) {
                this.scene = scene;
                this.world = world;
                this.meshes = [];
                this.material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
            }

            update() {
                const bodies = this.world.bodies;
                let meshIndex = 0;

                for (const body of bodies) {
                    for (const shape of body.shapes) {
                        let mesh = this.meshes[meshIndex];
                        if (!mesh) {
                            mesh = this.createMesh(shape);
                            if (mesh) {
                                this.meshes.push(mesh);
                                this.scene.add(mesh);
                            }
                        }

                        if (mesh) {
                            // 更新位置和旋转
                            const bodyPosition = new THREE.Vector3();
                            const bodyQuaternion = new THREE.Quaternion();
                            body.getShapeOffsetAndQuaternion(0, bodyPosition, bodyQuaternion)
                            mesh.position.copy(body.position).add(bodyPosition);
                            mesh.quaternion.copy(body.quaternion).multiply(bodyQuaternion);
                        }
                        meshIndex++;
                    }
                }

                // 移除多余的网格
                for (let i = meshIndex; i < this.meshes.length; i++) {
                    this.scene.remove(this.meshes[i]);
                }
                this.meshes.length = meshIndex;
            }
            
            createMesh(shape) {
                let mesh = null;
                switch (shape.type) {
                    case CANNON.Shape.types.BOX: {
                        const box = shape;
                        const geometry = new THREE.BoxGeometry(box.halfExtents.x * 2, box.halfExtents.y * 2, box.halfExtents.z * 2);
                        mesh = new THREE.Mesh(geometry, this.material);
                        break;
                    }
                    case CANNON.Shape.types.TRIMESH: {
                        const trimesh = shape;
                        const geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.BufferAttribute(trimesh.vertices, 3));
                        if (trimesh.indices) {
                            geometry.setIndex(new THREE.BufferAttribute(trimesh.indices, 1));
                        }
                        mesh = new THREE.Mesh(geometry, this.material);
                        break;
                    }
                }
                return mesh;
            }
        }
        
        let scene, camera, renderer, controls;
        let world, cannonDebugger; // 添加 cannonDebugger
        let tankBody, tankModel;
        const clock = new THREE.Clock();
        // ... (其他变量不变)

        init();
        animate();

        // --- 函数定义 ---
        function createCannonTrimesh(geometry) { /* ... 不变 ... */ return new CANNON.Trimesh(geometry.attributes.position.array, geometry.index.array); }

        function init() {
            scene = new THREE.Scene();
            // ... (renderer, camera, controls 初始化不变) ...
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.outputEncoding = THREE.sRGBEncoding; renderer.shadowMap.enabled = true; document.body.appendChild(renderer.domElement);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(0, 10, 20);
            controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true;

            world = new CANNON.World({ gravity: new CANNON.Vec3(0, -20, 0) });
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.allowSleep = true;

            // --- 实例化调试器 ---
            cannonDebugger = new CannonDebugger(scene, world);

            // ... (光照和环境贴图加载不变) ...
            const exrLoader = new EXRLoader(); exrLoader.load('assets/Minigame_Synth_Environment_4096x2048.exr', (texture) => { texture.mapping = THREE.EquirectangularReflectionMapping; scene.background = texture; scene.environment = texture; });
            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            const directionalLight = new THREE.DirectionalLight(0xffeeb1, 1); directionalLight.position.set(-20, 30, 20); directionalLight.castShadow = true; scene.add(directionalLight);

            loadModels();
            setupJoystick();
            window.addEventListener('resize', onWindowResize);
        }

        function loadModels() {
            // ... (合并几何体的逻辑完全不变) ...
            const loader = new GLTFLoader();
            loader.load('assets/Minigame_Synth_Scene.glb', (gltf) => {
                const sceneModel = gltf.scene;
                scene.add(sceneModel);
                const geometriesToMerge = [];
                sceneModel.traverse((child) => {
                    if (child.isMesh) {
                        child.receiveShadow = true;
                        const geo = child.geometry.clone();
                        geo.applyMatrix4(child.matrixWorld);
                        geometriesToMerge.push(geo);
                    }
                });
                if (geometriesToMerge.length > 0) {
                    const mergedGeometry = BufferGeometryUtils.mergeGeometries(geometriesToMerge, false);
                    mergedGeometry.setIndex(Array.from({ length: mergedGeometry.attributes.position.count }, (_, i) => i)); // 确保有索引
                    const sceneShape = createCannonTrimesh(mergedGeometry);
                    const sceneBody = new CANNON.Body({ mass: 0 });
                    sceneBody.addShape(sceneShape);
                    world.addBody(sceneBody);
                }
            });

            // ... (坦克加载逻辑不变) ...
            loader.load('assets/Minigame_Synth_Tank.glb', (gltf) => {
                tankModel = gltf.scene;
                scene.add(tankModel);
                tankModel.traverse((child) => { if (child.isMesh) child.castShadow = true; });
                const box = new THREE.Box3().setFromObject(tankModel);
                const size = new THREE.Vector3();
                box.getSize(size);
                const shape = new CANNON.Box(new CANNON.Vec3(size.x * 0.5, size.y * 0.5, size.z * 0.5));
                tankBody = new CANNON.Body({ mass: 50, position: new CANNON.Vec3(0, 5, 0), shape: shape, angularDamping: 0.95, linearDamping: 0.5 });
                world.addBody(tankBody);
            });
        }
        
        function setupJoystick() { /* ... 不变 ... */ const options = { zone: document.getElementById('joystick-zone'), mode: 'static', position: { left: '50%', top: '50%' }, color: 'cyan', size: 150, restJoystick: true }; const manager = nipplejs.create(options); manager.on('move', (evt, data) => { if (data.angle) { const angle = data.angle.radian; const force = data.force; joystickData.x = Math.cos(angle) * force; joystickData.z = -Math.sin(angle) * force; } }); manager.on('end', () => { joystickData.x = 0; joystickData.z = 0; }); }
        
        function onWindowResize() { /* ... 不变 ... */ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.1);
            world.step(1 / 60, deltaTime, 3);

            // --- 更新调试器 ---
            cannonDebugger.update();

            if (tankBody && tankModel) {
                // ... (坦克移动和相机逻辑不变) ...
                tankModel.position.copy(tankBody.position);
                tankModel.quaternion.copy(tankBody.quaternion);
                const moveSpeed = 20, turnSpeed = 4;   
                const controlVector = new CANNON.Vec3(joystickData.x, 0, joystickData.z);
                if (controlVector.lengthSq() > 0.01) {
                    const force = controlVector.z * moveSpeed;
                    const worldForce = tankBody.quaternion.vmult(new CANNON.Vec3(0, 0, force));
                    tankBody.velocity.x = worldForce.x * moveSpeed;
                    tankBody.velocity.z = worldForce.z * moveSpeed;
                    const turn = controlVector.x * -turnSpeed;
                    tankBody.angularVelocity.y = turn;
                } else {
                    tankBody.angularVelocity.y *= 0.8;
                }
                controls.target.copy(tankModel.position);
                controls.update();
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
