<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tank Physics Demo - Halloween Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; touch-action: none; }
        #fullscreen-prompt { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: white; background-color: rgba(0, 0, 0, 0.5); padding: 8px 15px; border-radius: 20px; font-family: sans-serif; font-size: 14px; pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 10; }
        .ui-button { position: absolute; background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(255, 255, 255, 0.4); cursor: pointer; padding: 10px; z-index: 100; opacity: 0.8; transition: opacity 0.2s, background-color 0.2s; border-radius: 50%; display: flex; align-items: center; justify-content: center; }
        .ui-button:hover { opacity: 1; background: rgba(0, 0, 0, 0.5); }
        .ui-button svg { display: block; width: 32px; height: 32px; }
        #music-toggle-btn { top: 15px; right: 15px; border-radius: 8px; }
        #reset-btn { top: 15px; right: 85px; border-radius: 8px; }
        #jump-btn { position: absolute; bottom: 30px; right: 50px; width: 80px; height: 80px; }
        #joystick-container { position: absolute; bottom: 30px; left: 50px; width: 120px; height: 120px; z-index: 10; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.149.0",
                "three/addons/": "https://esm.sh/three@0.149.0/examples/jsm/",
                "@dimforge/rapier3d-compat": "https://esm.sh/@dimforge/rapier3d-compat@0.13.1"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
</head>

<body>
    <div id="joystick-container"></div>
    <button id="jump-btn" class="ui-button" aria-label="Jump"><svg xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 0 24 24" width="48px" fill="#76FF33"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z"/></svg></button>
    <button id="reset-btn" class="ui-button" aria-label="Reset Tank"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#76FF33"><path d="M12 4c-4.41 0-8 3.59-8 8s3.59 8 8 8 8-3.59 8-8-3.59-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm-1-8v4h2v-4h3l-4-4-4 4h3z" fill-rule="evenodd"/></svg></button>
    <button id="music-toggle-btn" class="ui-button" aria-label="Toggle Music">
        <span id="music-icon-on" style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#76FF33"><path d="M12 3v9.28c-.47-.17-.97-.28-1.5-.28C8.01 12 6 14.01 6 16.5S8.01 21 10.5 21c2.31 0 4.2-1.75 4.45-4H15V6h4V3h-7z"/></svg></span>
        <span id="music-icon-off"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#76FF33"><path d="M4.27 3L3 4.27l9 9v.28c-.47-.17-.97-.28-1.5-.28-2.49 0-4.5 2.01-4.5 4.5S8.01 21 10.5 21c2.31 0 4.2-1.75 4.45-4H15v-1.73l5.73 5.73L22 19.73 4.27 3zM15 6h4V3h-7v4.18l2 2z"/></svg></span>
    </button>
    <div id="fullscreen-prompt">Tap to enter fullscreen & lock landscape</div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import RAPIER from '@dimforge/rapier3d-compat';

        let scene, camera, renderer, world, clock, mixer;
        let tankGroup, tankBody;
        
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        let audioContext, audioBuffer, sourceNode, isPlaying = false;

        const joystickVector = new THREE.Vector2();
        const keyboard = { forward: 0, turn: 0 };
        const cameraAngle = { horizontal: Math.PI, vertical: 0.4 };
        const cameraOffset = new THREE.Vector3(0, 4, 12);
        
        const maxSpeed = 25.0;
        const turnSpeed = 0.1;
        const jumpForce = 2500;
        const groundRaycastDist = 1.5;
        const initialTankPosition = { x: 3.5, y: 2, z: 0 };

        init();

        async function init() {
            await RAPIER.init();
            world = new RAPIER.World({ x: 0.0, y: -9.81, z: 0.0 });
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffeeb1, 1);
            directionalLight.position.set(-20, 30, 20);
            scene.add(directionalLight);
            
            await loadAssetsAndPhysics();
            setupControls();
            setupMusicControls();
            setupFullscreen();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        async function loadStaticModelAndCollider(url, position, rotation, scale) {
            const gltfLoader = new GLTFLoader();
            const gltf = await gltfLoader.loadAsync(url);
            const model = gltf.scene;
            model.position.copy(position);
            model.rotation.copy(rotation);
            model.scale.copy(scale);
            scene.add(model);

            const rigidBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed());
            model.updateWorldMatrix(true, true);

            model.traverse(child => {
                if (child.isMesh && child.geometry.attributes.position && child.geometry.index) {
                    child.receiveShadow = true;
                    child.updateWorldMatrix(true, true);
                    const vertices = child.geometry.attributes.position.array.slice();
                    const indices = child.geometry.index.array.slice();
                    
                    for (let i = 0; i < vertices.length; i += 3) {
                        const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
                        vertex.applyMatrix4(child.matrixWorld);
                        vertices[i] = vertex.x;
                        vertices[i + 1] = vertex.y;
                        vertices[i + 2] = vertex.z;
                    }
                    
                    const trimeshDesc = RAPIER.ColliderDesc.trimesh(new Float32Array(vertices), indices);
                    world.createCollider(trimeshDesc, rigidBody);
                }
            });
            return gltf;
        }

        async function loadAssetsAndPhysics() {
            const rgbeLoader = new RGBELoader();
            const gltfLoader = new GLTFLoader();
            const localAssetPath = 'assets/';

            try {
                const texture = await rgbeLoader.loadAsync(`${localAssetPath}venice_sunset_1k.hdr`);
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.environment = texture;
                
                const islandT4Gltf = await loadStaticModelAndCollider(
                    `${localAssetPath}island_t4.glb`,
                    new THREE.Vector3(0, -0.5, 0),
                    new THREE.Euler(0, Math.PI / 2, 0),
                    new THREE.Vector3(0.002, 0.002, 0.002)
                );
                mixer = new THREE.AnimationMixer(islandT4Gltf.scene);
                if (islandT4Gltf.animations.length > 0) {
                     mixer.clipAction(islandT4Gltf.animations[0]).play();
                }

                await loadStaticModelAndCollider(
                    `${localAssetPath}start.glb`,
                    new THREE.Vector3(3.5, 0, 0),
                    new THREE.Euler(0, Math.PI / 2, 0),
                    new THREE.Vector3(0.2, 0.2, 0.2)
                );
                
                const smallIslandGltf = await gltfLoader.loadAsync(`${localAssetPath}island_small.glb`);
                const radius = 19;
                const numIslands = 17;
                for (let i = 0; i < numIslands; i++) {
                    const islandInstance = smallIslandGltf.scene.clone(true);
                    const angle = (2 * -Math.PI * i) / numIslands;
                    const x = radius * Math.cos(angle);
                    const z = radius * Math.sin(angle);
                    const yRotation = -Math.PI / 2 + (2 * Math.PI * i) / numIslands;
                    
                    islandInstance.position.set(x, 0, z);
                    islandInstance.rotation.set(0, yRotation, 0);
                    islandInstance.scale.set(0.2, 0.2, 0.2);
                    scene.add(islandInstance);

                    const rigidBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed());
                    islandInstance.updateWorldMatrix(true, true);
                     islandInstance.traverse(child => {
                        if (child.isMesh && child.geometry.attributes.position && child.geometry.index) {
                             child.receiveShadow = true;
                             child.updateWorldMatrix(true, true);
                             const vertices = child.geometry.attributes.position.array.slice();
                             const indices = child.geometry.index.array.slice();
                             for (let j = 0; j < vertices.length; j += 3) {
                                 const vertex = new THREE.Vector3(vertices[j], vertices[j + 1], vertices[j + 2]);
                                 vertex.applyMatrix4(child.matrixWorld);
                                 vertices[j] = vertex.x;
                                 vertices[j + 1] = vertex.y;
                                 vertices[j + 2] = vertex.z;
                             }
                             const trimeshDesc = RAPIER.ColliderDesc.trimesh(new Float32Array(vertices), indices);
                             world.createCollider(trimeshDesc, rigidBody);
                        }
                    });
                }
                
                const tankGltf = await gltfLoader.loadAsync(`${localAssetPath}tank.glb`);
                tankGroup = new THREE.Group();
                tankGroup.position.set(initialTankPosition.x, initialTankPosition.y, initialTankPosition.z);
                scene.add(tankGroup);

                const tankVisualModel = tankGltf.scene;
                tankVisualModel.scale.set(0.0004, 0.0004, 0.0004);
                tankVisualModel.rotation.set(-Math.PI / 2, 0, Math.PI);
                tankGroup.add(tankVisualModel);
                
                const bodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(tankGroup.position.x, tankGroup.position.y, tankGroup.position.z).setLinearDamping(0.5).setAngularDamping(0.8).setCanSleep(false);
                tankBody = world.createRigidBody(bodyDesc);
                
                const allVertices = [];
                tankGroup.updateWorldMatrix(true, true);
                tankVisualModel.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.updateWorldMatrix(true, true);
                        const tempGeo = child.geometry.clone().applyMatrix4(child.matrixWorld);
                        const positions = tempGeo.attributes.position.array;
                        for (let i = 0; i < positions.length; i += 3) { allVertices.push(positions[i], positions[i+1], positions[i+2]); }
                    }
                });
                const colliderDesc = RAPIER.ColliderDesc.convexHull(new Float32Array(allVertices));
                world.createCollider(colliderDesc, tankBody);

            } catch (error) {
                console.error("An error occurred during asset loading:", error);
            }
        }

        // ... (The rest of the JS code is identical to the previous answer)

        function setupControls() {
            if (isTouchDevice) {
                const joystickManager = nipplejs.create({ zone: document.getElementById('joystick-container'), mode: 'static', position: { left: '80px', bottom: '80px' }, color: 'rgba(255,255,255,0.5)' });
                joystickManager.on('move', (evt, data) => { joystickVector.set(data.vector.x, data.vector.y); }).on('end', () => { joystickVector.set(0, 0); });
            }
            document.addEventListener('keydown', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w': case 'arrowup':    keyboard.forward = 1; break;
                    case 's': case 'arrowdown':  keyboard.forward = -1; break;
                    case 'a': case 'arrowleft':  keyboard.turn = -1; break;
                    case 'd': case 'arrowright': keyboard.turn = 1; break;
                    case ' ':                    handleJump(); break;
                }
            });
            document.addEventListener('keyup', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w': case 'arrowup': case 's': case 'arrowdown':  keyboard.forward = 0; break;
                    case 'a': case 'arrowleft': case 'd': case 'arrowright': keyboard.turn = 0; break;
                }
            });
            
            const cameraPointers = {};
            const rotationSpeed = 0.005;
            const tapThreshold = 10;
            const pointerDownPos = new THREE.Vector2();

            const onPointerDown = (e) => {
                if (e.target.closest('.ui-button') || e.target.closest('#joystick-container')) { return; }
                cameraPointers[e.pointerId] = { x: e.clientX, y: e.clientY };
                pointerDownPos.set(e.clientX, e.clientY);
            };

            const onPointerMove = (e) => {
                const pointer = cameraPointers[e.pointerId];
                if (pointer) {
                    const deltaX = e.clientX - pointer.x;
                    const deltaY = e.clientY - pointer.y;
                    cameraAngle.horizontal -= deltaX * rotationSpeed;
                    cameraAngle.vertical -= deltaY * rotationSpeed;
                    cameraAngle.vertical = Math.max(-Math.PI / 4, Math.min(Math.PI / 2.5, cameraAngle.vertical));
                    pointer.x = e.clientX;
                    pointer.y = e.clientY;
                }
            };

            const onPointerUpOrCancel = (e) => {
                if (cameraPointers[e.pointerId]) {
                    const dragDistance = pointerDownPos.distanceTo(new THREE.Vector2(e.clientX, e.clientY));
                    if (dragDistance < tapThreshold) { handleFullscreenRequest(); }
                }
                delete cameraPointers[e.pointerId];
            };
            
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            renderer.domElement.addEventListener('pointerup', onPointerUpOrCancel);
            renderer.domElement.addEventListener('pointercancel', onPointerUpOrCancel);
            renderer.domElement.addEventListener('pointerleave', onPointerUpOrCancel);

            const jumpButton = document.getElementById('jump-btn');
            const resetButton = document.getElementById('reset-btn');
            jumpButton.addEventListener('touchstart', (e) => { e.preventDefault(); handleJump(); }, { passive: false });
            jumpButton.addEventListener('click', handleJump);
            const resetTank = () => {
                if (!tankBody) return;
                tankBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
                tankBody.setAngvel({ x: 0, y: 0, z: 0 }, true);
                tankBody.setTranslation(initialTankPosition, true);
                tankBody.setRotation({ x: 0, y: 0, z: 0, w: 1 }, true);
            };
            resetButton.addEventListener('touchstart', (e) => { e.preventDefault(); resetTank(); }, { passive: false });
            resetButton.addEventListener('click', resetTank);
        }
        
        function handleJump() {
            if (!tankBody) return;
            const rayOrigin = tankBody.translation();
            const rayDir = { x: 0, y: -1, z: 0 };
            const ray = new RAPIER.Ray(rayOrigin, rayDir);
            const hit = world.castRay(ray, groundRaycastDist, true, null, null, tankBody.collider(0));
            if (hit) {
                tankBody.applyImpulse({ x: 0, y: jumpForce, z: 0 }, true);
            }
        }

        const cameraForward = new THREE.Vector3();
        const cameraRight = new THREE.Vector3();
        const moveDirection = new THREE.Vector3();
        const targetVelocity = new THREE.Vector3();
        const targetQuaternion = new THREE.Quaternion();
        const _matrix = new THREE.Matrix4();
        const upVector = new THREE.Vector3(0, 1, 0);

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            world.step();

            if (tankBody && tankGroup) {
                const moveInput = new THREE.Vector2( isTouchDevice ? joystickVector.x : keyboard.turn, isTouchDevice ? joystickVector.y : keyboard.forward );
                camera.getWorldDirection(cameraForward);
                cameraForward.y = 0;
                cameraForward.normalize();
                cameraRight.crossVectors(cameraForward, upVector);
                moveDirection.set(0, 0, 0);
                moveDirection.addScaledVector(cameraForward, moveInput.y);
                moveDirection.addScaledVector(cameraRight, moveInput.x);

                const currentVel = tankBody.linvel();
                if (moveDirection.lengthSq() > 0.01) {
                    moveDirection.normalize();
                    targetVelocity.copy(moveDirection).multiplyScalar(maxSpeed);
                    tankBody.setLinvel({ x: targetVelocity.x, y: currentVel.y, z: targetVelocity.z }, true);
                } else {
                    const brakingVel = { x: currentVel.x * 0.9, y: currentVel.y, z: currentVel.z * 0.9 };
                    tankBody.setLinvel(brakingVel, true);
                }
                
                const position = tankBody.translation();
                tankGroup.position.set(position.x, position.y, position.z);
                
                if (moveDirection.lengthSq() > 0.01) {
                    _matrix.lookAt(tankGroup.position, tankGroup.position.clone().sub(moveDirection), upVector);
                    targetQuaternion.setFromRotationMatrix(_matrix);
                    if (!tankGroup.quaternion.equals(targetQuaternion)) {
                        tankGroup.quaternion.slerp(targetQuaternion, turnSpeed);
                        tankBody.setRotation(tankGroup.quaternion, true);
                    }
                } else {
                     tankBody.setRotation(tankGroup.quaternion, true);
                }

                const rotatedOffset = cameraOffset.clone().applyAxisAngle(upVector, cameraAngle.horizontal);
                const horizontalAxis = new THREE.Vector3().crossVectors(upVector, rotatedOffset).normalize();
                rotatedOffset.applyAxisAngle(horizontalAxis, cameraAngle.vertical);
                const cameraTargetPosition = tankGroup.position.clone().add(rotatedOffset);
                camera.position.lerp(cameraTargetPosition, 0.1);
                camera.lookAt(tankGroup.position.clone().add(new THREE.Vector3(0, 1.5, 0)));
            }
            renderer.render(scene, camera);
        };
        
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
        
        function handleFullscreenRequest() { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().then(() => { if (isTouchDevice && screen.orientation && typeof screen.orientation.lock === 'function') { screen.orientation.lock('landscape').catch(() => {}); } }).catch(() => {}); } }
        
        function setupFullscreen() { 
            const prompt = document.getElementById('fullscreen-prompt'); 
            if (isTouchDevice) { 
                setTimeout(() => { prompt.style.opacity = '1'; }, 2000); 
                setTimeout(() => { prompt.style.opacity = '0'; }, 7000); 
            } else { 
                renderer.domElement.addEventListener('click', (e) => { 
                    if(e.target.closest('.ui-button')) return; 
                    handleFullscreenRequest()
                }); 
            } 
            document.addEventListener('fullscreenchange', () => { if (!document.fullscreenElement) { if (screen.orientation && typeof screen.orientation.unlock === 'function') { screen.orientation.unlock(); } } }); 
        };

        async function setupMusicControls() { 
            const musicButton = document.getElementById('music-toggle-btn'); 
            const iconOn = document.getElementById('music-icon-on'); 
            const iconOff = document.getElementById('music-icon-off'); 
            try { 
                const response = await fetch('assets/bounce tanki loop cut (no intro).opus'); 
                const arrayBuffer = await response.arrayBuffer(); 
                audioContext = THREE.AudioContext.getContext(); 
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer); 
            } catch (error) { 
                console.error('Failed to load or decode audio file:', error); 
                musicButton.disabled = true; 
                return; 
            } 
            function playMusic() { 
                if (isPlaying || !audioBuffer) return; 
                if (audioContext.state === 'suspended') { audioContext.resume(); } 
                sourceNode = audioContext.createBufferSource(); 
                sourceNode.buffer = audioBuffer; 
                sourceNode.loop = true; 
                sourceNode.connect(audioContext.destination); 
                sourceNode.start(); 
                isPlaying = true; 
                iconOn.style.display = 'inline'; 
                iconOff.style.display = 'none'; 
            } 
            function stopMusic() { 
                if (!isPlaying || !sourceNode) return; 
                sourceNode.stop(); 
                sourceNode.disconnect(); 
                sourceNode = null; 
                isPlaying = false; 
                iconOn.style.display = 'none'; 
                iconOff.style.display = 'inline'; 
            } 
            musicButton.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                if (isPlaying) { 
                    stopMusic(); 
                } else { 
                    playMusic(); 
                } 
            }); 
        }
    </script>
</body>

</html>
