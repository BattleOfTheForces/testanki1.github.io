<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tank Physics - Stable Load</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; touch-action: none; }
        /* 隐藏所有UI，专注于模型加载 */
        .ui-button, #joystick-container { display: none; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://esm.sh/three@0.149.0", "three/addons/": "https://esm.sh/three@0.149.0/examples/jsm/", "@dimforge/rapier3d-compat": "https://esm.sh/@dimforge/rapier3d-compat@0.13.1" } }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import RAPIER from '@dimforge/rapier3d-compat';

        let scene, camera, renderer, world, clock, mixer;

        async function init() {
            // 1. 基础场景设置
            await RAPIER.init();
            world = new RAPIER.World({ x: 0.0, y: -9.81, z: 0.0 });
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            renderer = new THREE.WebGLRenderer({ antialias: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 15, 25); // 设置一个能看全景的固定机位
            camera.lookAt(0, 0, 0);
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(10, 20, 5);
            scene.add(dirLight);

            // 2. 依次加载所有资源
            try {
                await loadAssets();
            } catch (error) {
                // 如果任何一步失败，在屏幕上显示一个巨大的错误信息
                const errorDiv = document.createElement('div');
                errorDiv.style.position = 'absolute';
                errorDiv.style.top = '0';
                errorDiv.style.left = '0';
                errorDiv.style.width = '100%';
                errorDiv.style.height = '100%';
                errorDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
                errorDiv.style.color = 'white';
                errorDiv.style.fontSize = '24px';
                errorDiv.style.display = 'flex';
                errorDiv.style.justifyContent = 'center';
                errorDiv.style.alignItems = 'center';
                errorDiv.style.textAlign = 'center';
                errorDiv.style.zIndex = '9999';
                errorDiv.innerHTML = `LOADING FAILED!<br>Check file names and integrity.<br>Error: ${error.message || 'Unknown'}`;
                document.body.appendChild(errorDiv);
            }

            // 3. 启动渲染循环
            animate();
        }

        // 统一的模型处理函数
        function processModel(model, scale, position, rotation) {
            model.scale.set(scale.x, scale.y, scale.z);
            model.position.set(position.x, position.y, position.z);
            if (rotation) model.rotation.set(rotation.x, rotation.y, rotation.z);
            scene.add(model);
            
            // 为所有子网格创建物理碰撞体
            model.updateWorldMatrix(true, true);
            const rigidBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed());
            model.traverse(child => {
                if (child.isMesh && child.geometry) {
                    const vertices = child.geometry.attributes.position.array.slice();
                    const indices = child.geometry.index.array.slice();
                    const worldMatrix = child.matrixWorld;
                    for (let i = 0; i < vertices.length; i += 3) {
                        const v = new THREE.Vector3(vertices[i], vertices[i+1], vertices[i+2]).applyMatrix4(worldMatrix);
                        vertices[i] = v.x; vertices[i+1] = v.y; vertices[i+2] = v.z;
                    }
                    world.createCollider(RAPIER.ColliderDesc.trimesh(new Float32Array(vertices), indices), rigidBody);
                }
            });
        }

        async function loadAssets() {
            const rgbeLoader = new RGBELoader();
            const gltfLoader = new GLTFLoader();
            const localAssetPath = 'assets/';

            // --- 按最直接的方式一步步加载 ---

            // 步骤 1: 背景
            const hdrTexture = await rgbeLoader.loadAsync(`${localAssetPath}venice_sunset_1k.hdr`);
            hdrTexture.mapping = THREE.EquirectangularReflectionMapping;
            scene.background = hdrTexture;
            scene.environment = hdrTexture;

            // 步骤 2: 中央岛屿
            const islandT4Gltf = await gltfLoader.loadAsync(`${localAssetPath}island_t4.glb`);
            processModel(islandT4Gltf.scene, {x:0.002, y:0.002, z:0.002}, {x:0, y:-0.5, z:0}, new THREE.Euler(0, Math.PI / 2, 0));
            mixer = new THREE.AnimationMixer(islandT4Gltf.scene);
            if (islandT4Gltf.animations.length > 0) mixer.clipAction(islandT4Gltf.animations[0]).play();

            // 步骤 3: 起始岛屿
            const startGltf = await gltfLoader.loadAsync(`${localAssetPath}start.glb`);
            processModel(startGltf.scene, {x:0.2, y:0.2, z:0.2}, {x:3.5, y:0, z:0}, new THREE.Euler(0, Math.PI / 2, 0));

            // 步骤 4: 小岛屿
            const smallIslandGltf = await gltfLoader.loadAsync(`${localAssetPath}island_small.glb`);
            const radius = 19;
            const numIslands = 17;
            for (let i = 0; i < numIslands; i++) {
                const islandInstance = smallIslandGltf.scene.clone(true); // 克隆模型
                const angle = (2 * -Math.PI * i) / numIslands;
                const yRotation = -Math.PI / 2 + (2 * Math.PI * i) / numIslands;
                processModel(islandInstance, {x:0.2, y:0.2, z:0.2}, {x: radius * Math.cos(angle), y:0, z: radius * Math.sin(angle)}, new THREE.Euler(0, yRotation, 0));
            }

            // 步骤 5: 坦克
            const tankGltf = await gltfLoader.loadAsync(`${localAssetPath}tank.glb`);
            const tankModel = tankGltf.scene;
            tankModel.scale.set(0.004, 0.004, 0.004); // 放大一点，方便看到
            tankModel.position.set(3.5, 1, 0); // 放在起始岛屿上
            scene.add(tankModel);
            // 坦克的物理暂时简化，我们只关心加载
        }
        
        function animate() {
            requestAnimationFrame(animate);
            if (clock && mixer) {
                mixer.update(clock.getDelta());
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
